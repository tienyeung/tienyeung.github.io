<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tienyeung.github.io/</id>
    <title>阳阳の部落格</title>
    <updated>2020-04-25T14:13:41.564Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tienyeung.github.io/"/>
    <link rel="self" href="https://tienyeung.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://tienyeung.github.io/images/avatar.png</logo>
    <icon>https://tienyeung.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 阳阳の部落格</rights>
    <entry>
        <title type="html"><![CDATA[ta好像一条狗]]></title>
        <id>https://tienyeung.github.io/post/ta-hao-xiang-yi-tiao-gou</id>
        <link href="https://tienyeung.github.io/post/ta-hao-xiang-yi-tiao-gou">
        </link>
        <updated>2020-04-25T14:04:52.000Z</updated>
        <summary type="html"><![CDATA[<p>从前，有条没有尾巴的狗。 别的狗都是有尾巴的，它们摇一摇尾巴，就能表示出内心的想法。如果感到高兴，它们就朝上摇尾巴。如果心情不好，它们就把尾巴耷拉下来慢慢地摇。 可只有一条狗，它是没有尾巴的狗。 别的狗对它摇摇尾巴，说“你好呀”。无尾狗也想对对方摇摇尾巴，说句你好。可是它没有尾巴，只能看着对方，不知道如何表示。</p>
]]></summary>
        <content type="html"><![CDATA[<p>从前，有条没有尾巴的狗。 别的狗都是有尾巴的，它们摇一摇尾巴，就能表示出内心的想法。如果感到高兴，它们就朝上摇尾巴。如果心情不好，它们就把尾巴耷拉下来慢慢地摇。 可只有一条狗，它是没有尾巴的狗。 别的狗对它摇摇尾巴，说“你好呀”。无尾狗也想对对方摇摇尾巴，说句你好。可是它没有尾巴，只能看着对方，不知道如何表示。</p>
<!-- more -->
<p>那条狗等了半天，无尾狗毫无表示，于是它走了。 久而久之，别的狗就都不跟无尾狗玩儿了。因为它看起来不亲切，又与众不同。<br>
无尾狗也觉得自己与众不同、不够亲切，这当然都是自己的错。于是它立志要做一条善良温柔的好狗。 它以为，做一条善良温柔的好狗，别的狗才会喜欢它啊。<br>
无尾狗感觉很伤心。别的狗感到伤心的时候都会把尾巴耷拉下来，可是无尾狗没有尾巴，它没有办法表示出它很伤心。 这世界上没人知道它很伤心。<br>
别的狗欺负它，它也没法表示出它很生气。 从来都没人在意它的感受。 别的狗都觉得，这真是一条好脾气的傻狗呀。<br>
无尾狗终于在自己的生日那天，悄悄地许了一个愿望：希望能够遇见一条在乎自己感受的狗伴侣。希望它能在自己感到难过的时候，发现这一点。 因为无尾狗一直在考虑着别的狗的感受，可是自己感到难过的时候，却没人知道。 无尾狗的心情一直不怎么好。 生而为狗，它很抱歉。</p>
<p>我就是那条无尾狗。<br>
别扭又深情，怪异而孤独。<br>
总觉得自己特别热爱生活，可生活中的小确丧却时时消磨着我前行的勇气。</p>
<p>小的时候总以为自己长大会变成很厉害的人。后来知道自己没希望了，那就变成成功圆满的人也可以啊。<br>
再后来觉得，即使普通，只要度过快乐幸福的人生就好。<br>
再后来，发现只要活着就行。对自己提出要求，只会令人痛苦。<br>
我只是觉得，这么多年了，我一点长进都没有。<br>
一点都没有。<br>
年龄不断增长，我在变老。一切都在无法阻止地走向市侩和庸俗。<br>
可我还是一点长进都没有。<br>
不懂事，不会办事，不会做人。<br>
所以就很拧巴，就很颓然。<br>
我对人情世故所知甚少，却并未拥有令人忽略这些的才华。</p>
<center><u>转载自知乎</u></center>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的互联网十年]]></title>
        <id>https://tienyeung.github.io/post/wo-de-hu-lian-wang-shi-nian</id>
        <link href="https://tienyeung.github.io/post/wo-de-hu-lian-wang-shi-nian">
        </link>
        <updated>2019-12-31T12:04:26.000Z</updated>
        <summary type="html"><![CDATA[<p>偶然读到的一条资讯告诉我人人网“复活了”，其实我知道人人网一直未死，只是丢失了初心的它以切入直播市场的姿态苟且偷生着。读到这则消息，我迫不及待下载了人人网app。我会如此怀念这个曾经主打校园社交的门户网站，倒不是因为它上面有我的社交关系以及与之相关的回忆，而是在非智能机时代，我的资讯、“深度好文”、段子的来源就是它，没有知乎，微博，各类自媒体的年代，我的对外界的认知来源就是这么狭窄却欢乐，如今信息开始爆炸，我反而愈加焦虑和不安，我开始怕我跟不上这个发展极度迅猛的时代了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>偶然读到的一条资讯告诉我人人网“复活了”，其实我知道人人网一直未死，只是丢失了初心的它以切入直播市场的姿态苟且偷生着。读到这则消息，我迫不及待下载了人人网app。我会如此怀念这个曾经主打校园社交的门户网站，倒不是因为它上面有我的社交关系以及与之相关的回忆，而是在非智能机时代，我的资讯、“深度好文”、段子的来源就是它，没有知乎，微博，各类自媒体的年代，我的对外界的认知来源就是这么狭窄却欢乐，如今信息开始爆炸，我反而愈加焦虑和不安，我开始怕我跟不上这个发展极度迅猛的时代了。</p>
<!-- more -->
<p>打开app，它上面告诉我距离注册人人网已有3180天。我用来注册的手机账号早已不复存在，看着这个手机号，我仿佛穿越到9年前初中高中的岁月，那时候才真是岁月静好，听着课，发着呆，看着喜欢女生的后脑勺，那时的我怎么就这么无忧无虑，怎么就这么没心没肺。一切都好似昨天，怎么转眼就来到了2019年，而且2019也即将逝去，明天就迎接2020了，这个在无数小说、电影里提及的科幻年代，正在势不可挡的滚滚而来。</p>
<p>9年前，每月30M的流量，一部金立的功能机，我就能刷人人、猫扑刷得不亦乐乎，我对如今许多段子或梗完全不感冒，甚至觉得尬，很大程度源自我已经在人人，猫扑上看过其雏形了，一个段子或梗好笑，许多时候是因为它的出其不意，意料之外，对我来说许多段子看过一遍后就很难觉得好笑了。这不像许多影视桥段，比如周星驰许多天马行空的无厘头镜头，不管看过多少遍，我仍然会觉得好笑，原因在于周先生表现出来的是多维度的，而不是单纯在文字角度给予我冲击。</p>
<p>人人和猫扑给了我互联网文化的启蒙，前者延伸了我的深度，后者拓展了我的广度，在信息相对匮乏的年代，二者与我而言都意义非凡。高中起，我便很少花时间在二者上了，一方面在于学业繁忙无暇浏览，再者二者也开始式微了，后继乏力，我看着它们往远离初心的方向越来越远，开始直播，开始卖肉，但我对此感到理解，因为智能机横空出世，一个全新的移动互联网时代即将来临，一切适应不了变化的事物都将随时代远去。信息化社会快速发展，一系列社交，资讯，自媒体产品正如雨后春笋般铺陈开来，我也搭上了这这辆列车，开始尝试全新的app，融入这个联系更为紧密的新时代。</p>
<p>我的大学开始了，知乎成了我难以避免的时间黑洞，那时候知乎方兴未艾，一个屠龙少年以一种英雄的姿态踩着恶龙意气风发，虽难掩青涩，但我们都知道这个少年将会快速成长，将会成为一颗闪亮的新星。那时候的知乎号称精英社区，早期的人员组成几乎全为大学生、白领，各领域大牛等高知人群，提问+回答的一对多的形式，真的让我耳目一新，它让我知道对于一个问题的理解不止一个角度，另辟蹊径，脑洞大开更是成了常态，这个世界原来是如此精彩，如此丰富多彩。xxx是种什么体验?如何看待xxx？等是知乎常见的提问体，而 谢邀，以上，用一个故事来侧面回答的回答体也让我记忆犹新。但屠龙少年终究会变成以前他厌恶的模样，随着体量的庞大，不能靠爱发电，终究要盈利的，于是，屠龙少年成了恶龙，我不知道下个“知乎”何时到来，但我知道如今流传的“人在xx，刚下飞机”，“一觉醒来xxx”，“知乎，分享你刚编的故事”的知乎，已如同人人，猫扑一样偏离了初心，不再是我疯狂喜爱的知识媒介了，只能偶尔浏览打发无聊罢了。</p>
<p>另一个值得一提的是微信，微信如今是无人不知无人不晓的超级app，牢牢捍卫着其社交流量第一名的地位毫不动摇，早期的微信我并不屑于用，因为我不知道一个与qq高度相似的且同属于一加公司的app为何出现，后来我知道了随着移动互联网的兴起，一个有着移动基因的app必须诞生，微信应运而生。我是较晚才开始使用微信的，原因不外乎是我的家人都在用，我也不得不用以和他们联系。其实微信的UI一开始很难符合我的审美，过于简陋也不够现代化，配色图标等都不符合当时流行的质感设计（MD），我真正对其着迷，甚至离不开还是随着他的改版以及小程序的出现，让我发现微信正在变得越来越好，我也意识到，一个占据中国大部分社交市场的超级软件已经逐渐形成，另一个我离不开的原因在于公众号。公众号实在是一个极为伟大的发明，将资讯信息嵌入到社交软件中，这是个巨大的红利市场，自媒体时代将由此拉开，如今开来，也正是如此，公众号养活了几千家自媒体，许多人能以低成本的方式靠码字生存，其中头部的公众号也赢得了资本家的青睐，成为这场移动互联网狂欢的胜利者。我每天打开微信的原因，不在于聊天（其实是根本没人找我聊天），而是看看我关注的公众号有没有更新，仅此而已。我很少收发朋友圈，一方面是躺在我好友列表的好友实在不多，我没必要经常刷新，另一个方面是我觉得太累了，发一条朋友圈要斟酌好久，还要在意是否有人点赞有人评论，所以发在朋友圈上的都是我觉得实在想发的（其实就是满足我无处安放的社交欲望），但许多时候我发的都不是我真正想说的，我怕别人会说我矫情，所以大多数时候，我会发在微博上，反正无人关注也无人认识，也就放飞自我啦~</p>
<p>后来我时而会点开的app是网易云音乐，酷安，豆瓣等，许多时候我都不知道点开干嘛，只是下意识点开打发无聊而已，信息发放的渠道越来越多，我也变得愈加焦虑，我前面说过我害怕跟不上这个信息爆炸的社会，我什么都想学，什么都想知道，于是我点开各种app，快速浏览着资讯，我也不知道我到底看进去了多少，学到了多少，但这种碎片化的阅读只会让我误以为我学到了东西，其实过后，再次回忆时，我并不记得多少。很多次，我都告诉我，看过了总会留下印象和痕迹的，但我知道，我只是在自我安慰与自我麻痹而已，跟不上的始终跟不上，学不到仍旧学不到，我不可能看完所有信息，资讯app如同今日头条的智能推荐系统牢牢把握用户的心理，仿佛上瘾一般会让人不断刷下去。</p>
<p>我的互联网十年，我只是着重拣了几个我认为有代表性的来讲，其实在承载我美好时光的app记忆远远不止这么几个，有太多的青春记忆伴随着互联网高速列车急速前行。我写这篇文章的原因也仅仅是由人人网复活而有感而发，我承认我是个喜欢怀旧的人，尤其是这个即将迈入新年的时间点上。回顾我的互联网十年，最难以忘怀的仍然是我刚刚接触互联网的时候，那时的我真是小白一个，不会注册qq，不会搜索，互联网的启蒙和我在社交网络世界发出的第一个字是我在初一的微机课上当时的一位挚友教我的，自我初中转学后便失去联系，但我仍然会铭记这个人和这段时光的。我玩的第一款游戏叫DNF，就在一个月前我仍然在玩，期间虽断断续续，我也实在是天资平平，至今没成为dnf中战力超群的存在，但这就是我的青春啊，我也会记得带我入这个坑的那位朋友，记得那个PC并不普及的年代，囊中羞涩的我和朋友周末必去网吧玩上一把，两块钱一小时的时光是多么惬意和记忆尤深啊，如今，再让我去网吧花5块钱坐上一小时我会觉得如坐针毡。</p>
<p>十年前我没有自己的手机，用着我妈的手机登上qq时我会觉得相当兴奋，因为我又可以与网友聊天了，那时候，才真是网友，我搜索着与我相近年龄的菇凉，然后她们也会不厌其烦地和我聊天，现在回想，那就是在尬聊，说着无厘头的话，没心没肺得聊着，谁也不会有任何利益性，只想着在网络世界里，两个彼此陌生的人袒露着心扉，诉说着在现实世界难以言表的话语。</p>
<p>青涩的暗恋也发生在qq上，在我的前学生时代的每个阶段总会有女孩与我聊天，在这个时候我会觉得很幸福，我扮演着我在互联网上无厘头，现实高冷的角色，与我喜欢的女孩或喜欢我的女孩聊着天，我并不善于主动找人家聊，时常是她们来找我，此时我会尽我所能地表现我的幽默感，我逐字斟酌着发出去的话语，想象她看到时的反应，我会因为她的一句话害羞，也会因为一句话怦然心动，但即便如此，我没能和其中的任何一位有着进一步的关系，大多数时候都是我退缩或是因为毕业后较少联络而不了了之，回首看来，女孩能主动找我聊天是我莫大的荣幸，她们能忍受我的不成熟与略显幼稚的无厘头是对我很大的包容。如今，有的再无联系，有的已为人妇，时光的雕刻手法实在让我捉摸不透与心生感叹。研究生阶段，我时常会感到孤独，这是从前不常有的，很少有人找我聊天，我也再没有了暗恋的菇凉，如今社交网络如此发达，社交app层出不穷，我反倒生出了10年前不曾有过的孤独情绪，那个交流不发达的年代有这么多人陪在我身边，这个看似更便利更现代化的时代为何我却找不出哪怕一个人可以分享彼此的喜悦和难受呢。qq这个承载我无数青涩记忆的app也已不是我从前认识的模样了，我不知道是它变了还是我变了，亦或是时代变了，我如今极少打开这个app，躺在我聊天列表的人许多头像已经黯淡，也许他们也知道，是时候换个社交环境了。qq空间我也极少打开，因为我刷到的动态甚至几天里都不曾更新过，我在这上面留下的记忆回顾起来同样让我脸酸，以前的我怎么这么无厘头和这么真实啊，如今，我的qq空间总浏览量在5600多停滞不前，上一次发动态已经出10个月前了，仿佛世界与我隔离许久一般。</p>
<p>我想找个人聊天，但细想想，他们都有自己的事，他们也不再是我认识的以前的他们了，大家都在变化，而我，驻留在原地，不断回首过往，踟蹰不前。我陷在了记忆的深渊里，过往皆是美好，而现实一成不变。过往的岁月已然过去，但是我仍旧铭记这点点滴滴。</p>
<p>2019过去了，我很怀念她。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找]]></title>
        <id>https://tienyeung.github.io/post/er-fen-cha-zhao</id>
        <link href="https://tienyeung.github.io/post/er-fen-cha-zhao">
        </link>
        <updated>2019-11-12T11:16:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>二分查找看似简单，实则暗藏杀机，有时需要改变模板才能适应题目，所谓细节处见魔鬼。</p>
</blockquote>
<blockquote>
<p>Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky.</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>二分查找看似简单，实则暗藏杀机，有时需要改变模板才能适应题目，所谓细节处见魔鬼。</p>
</blockquote>
<blockquote>
<p>Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky.</p>
</blockquote>
<!-- more -->
<h1 id="1左右闭区间">1.左右闭区间</h1>
<p>所谓左右闭区间就是在查找时，左右边界的数值也应该在查找范围内</p>
<pre><code class="language-java">int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left &lt;= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] &lt; target)
            left = mid + 1; // 注意
        else if (nums[mid] &gt; target)
            right = mid - 1; // 注意
        }
    return -1;
}
</code></pre>
<ul>
<li>注意几点：</li>
</ul>
<ol>
<li>right = nums.length - 1</li>
<li>left&lt;=right</li>
<li>l=mid+1</li>
<li>r=mid-1</li>
<li>return mid</li>
</ol>
<h1 id="2寻找左侧边界的二分搜索">2.寻找左侧边界的二分搜索</h1>
<p>当一个数组中存在多个要查找的值时，返回最左边的索引</p>
<pre><code class="language-java">int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意
    
    while (left &lt; right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] &lt; target) {
            left = mid + 1;
        } else if (nums[mid] &gt; target) {
            right = mid; // 注意
        }
    }
    return nums[left] == target ? left : -1;
}
</code></pre>
<ul>
<li>注意几点：</li>
</ul>
<ol>
<li>right = nums.length</li>
<li>left&lt;right</li>
<li>l=mid+1</li>
<li>r=mid</li>
<li>return left</li>
</ol>
<h1 id="3-寻找右侧边界的二分查找">3. 寻找右侧边界的二分查找</h1>
<pre><code class="language-java">int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;
    
    while (left &lt; right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] &lt; target) {
            left = mid + 1;
        } else if (nums[mid] &gt; target) {
            right = mid;
        }
    }
    // return left - 1; // 注意
		return nums[left-1] == target ? (left-1) : -1;
}
</code></pre>
<p>大致和左侧边界的算法相同，但还需注意几点不同：</p>
<ol>
<li>right = nums.length</li>
<li><strong>l=mid+1（nums[mid] = target）</strong></li>
<li>left&lt;right</li>
<li>l=mid+1（nums[mid] &lt; target）</li>
<li>r=mid</li>
<li><strong>return left-1</strong></li>
</ol>
<p><a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/">详细解说</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[买票找零问题]]></title>
        <id>https://tienyeung.github.io/post/mai-piao-zhao-ling-wen-ti</id>
        <link href="https://tienyeung.github.io/post/mai-piao-zhao-ling-wen-ti">
        </link>
        <updated>2019-10-25T06:32:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在一场激烈的足球赛开始前，售票工作正在紧张地进行中。每张球票为50元。现有2n个人排队购票，其中有n个人手持50元的钞票，另外n个人手持100元的钞票，假设开始售票时售票处没有零钱。问这2n个人有多少种排队方式，不至使售票处出现找不开钱的局面？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在一场激烈的足球赛开始前，售票工作正在紧张地进行中。每张球票为50元。现有2n个人排队购票，其中有n个人手持50元的钞票，另外n个人手持100元的钞票，假设开始售票时售票处没有零钱。问这2n个人有多少种排队方式，不至使售票处出现找不开钱的局面？</p>
</blockquote>
<!-- more -->
<p>从这篇博客起，讲述的是算法中的数学问题。此类算法一般不涉及到精妙的解题步骤，而是考虑到复杂的数学思想。</p>
<h1 id="解法1">解法1</h1>
<p>我们可以把此问题看作是括号匹配问题，一个50元匹配一个100元，相当于一个左括号匹配一个右括号，保留一个栈，压入左括号，遇到右括号时弹出，如果保证栈中有足够多的左括号，则说明该序列为合法序列。<br>
可作如下分析，第一个符号一定是左括号，假设第一个符号和第k个符号匹配，那么第二个符号到第k-1个符号之间为合法序列，第k+1个符号到2n也是合法序列，可想而知，k一定为奇数，设k=2i+1(i=0,1,...n)<br>
<img src="https://i.loli.net/2019/10/25/ij6NFPclkUw4b8O.png" alt="untitled.png" loading="lazy"><br>
假设2n个符号中合法的括号序列之个数为f（2n），若第一个左括号与第k＝2i＋1（i＝0，1，…，n－1）个右括号匹配，那么剩余括号的合法序列为：f（2i）*f（2n－2i－2）个，根据上面的分析，可以得到如下递推式：<br>
<img src="https://i.loli.net/2019/10/25/9LJMOl3dYHwDKx6.png" alt="untitled1.png" loading="lazy"><br>
f(0)=1,则可在平方级时间复杂度内求出答案</p>
<h1 id="解法2">解法2</h1>
<p>为了便于描述，这里用1表示持有50元的球迷，用0表示持有100元的球迷。那么2n个球迷的排队就对应n个1和n个0的排列.如果序列的任意前k（k＝1，2，…，2n－1）项中1的个数都不少于0的个数，我们称这样的一个序列是合法的，否则称其为非法的。显然合法的序列正好与可行的排列方式一一对应。同时，称由n－1个1和n＋1个0组成的序列为Sigma序列（这个名字没有任何特别的意义），这样的序列共有(2n n-1)个。</p>
<p>n个1和n个0总的排列数为(2n n)个，即合法序列数和非法序列数的总和。我们需要求解合法的序列数，但在尝试后会发现直接求解合法序列并不是一个好的主意，那就试着来求解非法序列吧。<br>
由定义知道，在一个非法序列中，存在某个（些）k，使得序列前k项中1的个数少于0的个数。更进一步地，存在某个（些）k，使得序列前k项中1的个数比0的个数刚好少1个。取其中最小的k，使得前k项中1的个数比0的个数刚好少1个。那么这个序列的后2n－k项中1的个数会刚好比0的个数多1个。将后2n-k项的0换为1，1换为0，于是得到一个新的序列：由n－1个1和n＋1个0组成一个Sigma序列。我们已经成功地将一个非法序列对应到唯一一个Sigma序列。</p>
<p>那么一个Sigma序列能唯一地对应到一个非法序列么？对任意一个Sigma序列，存在某个（些）k，使得序列的前k项中1的个数少于0的个数（因为只有n－1个1，而有n＋1个0）。更进一步地，存在某个（些）k，使得序列的前k项中1的个数比0的个数刚好少1个。取其中最小的k，使得前k项中1的个数比0的个数刚好少1个。那么这个序列的后2n－k项中1的个数会刚好比0的个数少1个。将后2n－k项的0换为1，1换为0，于是得到一个新的序列：由n个1和n个0组成。而这个序列正是一个非法的序列（因为前k项中1的个数比0少）。我们又成功地将一个Sigma序列对应到唯一一个非法序列。</p>
<p><strong>由此我们知道，非法序列和Sigma序列是一一对应的。非法的序列个数为(2n n-1)个，合法的序列数：<br>
(2n n)-(2n n-1)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>*(2n n)</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[还原二叉树]]></title>
        <id>https://tienyeung.github.io/post/huan-yuan-er-cha-shu</id>
        <link href="https://tienyeung.github.io/post/huan-yuan-er-cha-shu">
        </link>
        <updated>2019-10-24T01:22:50.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>根据先序遍历和中序遍历的结果来还原二叉树</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>根据先序遍历和中序遍历的结果来还原二叉树</p>
</blockquote>
<!-- more -->
<p><em>Today is 1024 Programmer's Day</em><br>
<em>Cheer Up!</em><br>
<em>haha!</em></p>
<p>前序遍历：先访问当前节点，然后以前序访问左子树，右子树。<br>
中序遍历：先以中序遍历左子树，接着访问当前节点，然后以中序遍历右子树。<br>
根据前序遍历和中序遍历的特点，可以发现如下规律：<br>
前序遍历的每一个节点，都是当前子树的根节点。同时，以对应的节点为边界，就会把中序遍历的结果分为左子树和右子树。<br>
<img src="https://i.loli.net/2019/10/24/3hvtZcwTfVYJqml.png" alt="untitled.png" loading="lazy"><br>
前序：<br>
<strong>a</strong> b d c e f<br>
“a”是根节点<br>
中序：<br>
d b <strong>a</strong> e c f<br>
“a”是根节点，把字符串分成左右两个子树<br>
“a”是前序遍历节点中的第一个元素，可以看出，它把中序遍历的结果分成“db”和“ecf”两个部分。可以从图中看出，这就是“a”的左子树和右子树的遍历结果。<br>
如果能够找到前序遍历中对应的左子树和右子树，就可以把“a”作为当前的根节点，然后依次递归下去，这样就能够把左子树和右子树的遍历结果给依次恢复出来。<br>
<strong>节点类</strong></p>
<pre><code class="language-c">struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * }
</code></pre>
<p><strong>构建二叉树</strong></p>
<pre><code class="language-c">class Solution {
public:
    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) {
        if(pre.size() == 0)
            return NULL;//无节点返回NULL
        int rootValue = pre[0];
        TreeNode* newRoot = new TreeNode(rootValue);
        newRoot-&gt;left = newRoot-&gt;right = NULL;
        if(pre.size() == 1) {
            return newRoot;
        }//单节点返回
        vector&lt;int&gt; preL, preR, vinL, vinR;
        for (int i = 0 ; i &lt; (int)vin.size() ; i++) {
            if (vin[i] == rootValue) {
                for (int j = i+1 ; j &lt; (int)vin.size(); j++) {
                    vinR.push_back(vin[j]);
                    preR.push_back(pre[j]);
                }
                break;
            }
            vinL.push_back(vin[i]);
            preL.push_back(pre[i+1]); 
        }//大于两个节点时对数组进行划分
        newRoot-&gt;left = reConstructBinaryTree(preL,vinL);
        newRoot-&gt;right = reConstructBinaryTree(preR,vinR);
        return newRoot;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电话号码对应英语单词]]></title>
        <id>https://tienyeung.github.io/post/dian-hua-hao-ma-dui-ying-ying-yu-dan-ci</id>
        <link href="https://tienyeung.github.io/post/dian-hua-hao-ma-dui-ying-ying-yu-dan-ci">
        </link>
        <updated>2019-10-23T02:17:22.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>1.手机上，数字键对应多个字母，如何根据这样的对应关系设计一个程序，找出一段号码所代表的所有字符串<br>
2.对于一个电话号码，是否可以用一个单词来代表呢？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>1.手机上，数字键对应多个字母，如何根据这样的对应关系设计一个程序，找出一段号码所代表的所有字符串<br>
2.对于一个电话号码，是否可以用一个单词来代表呢？</p>
</blockquote>
<!-- more -->
<h1 id="题目1">题目1</h1>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2 ABC</th>
<th style="text-align:center">3 DEF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4 GIH</td>
<td style="text-align:center">5 JKL</td>
<td style="text-align:center">6 MNO</td>
</tr>
<tr>
<td style="text-align:center">7 PQRS</td>
<td style="text-align:center">8 TUV</td>
<td style="text-align:center">9 WXYZ</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>除了0、1之外，其他数字上都最少有3个字符，其中7、9上有4个字符，我们假设0、1输出的是空字符。</p>
</blockquote>
<pre><code class="language-java">package algorithm;
 
public class Num2Letter {
	
	private static char c[][] = {
			{},				//0
			{},				//1
			{'A','B','C'},			//2
			{'D','D','E'},			//3
			{'G','H','I'},			//4
			{'J','K','L'},			//5
			{'M','N','O'},			//6
			{'P','Q','R','S'},		//7
			{'T','U','V'},			//8
			{'W','X','Y','Z'}		//9
	};
	
	private static int total[] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};	//各个数字所能代表的字符总数
	
	//int number[];							//存储电话号码的数组
	//int answer[];							//数字目前所代表的字符在其所能代表的字符集中的位置
	//int TelLength = 0;
	
	public static void PrintResult(String telNumber){
		int TelLength = telNumber.length();
		int[] number=new int[TelLength];
		int[] answer=new int[TelLength];
        //answer储存的是当前号码上的字母序号，比如answer[0]=0代表电话号码的第一位数字所对应的第一个字母
		for(int i=0; i&lt;TelLength; i++){
			number[i]=telNumber.charAt(i)-'0';
			answer[i]=0;
		}
		//DirectSearch(number,answer, TelLength);
		RecursiveSearch(number, answer, 0, TelLength);
		
	}
	
	private static void DirectSearch(int[] number, int[] answer, int TelLength){	//解法一、直接循环法
		while(true){
			for(int i=0; i&lt;TelLength; i++){
				System.out.print(c[number[i]][answer[i]]);
			}
			System.out.println(&quot;&quot;);
			int k=TelLength-1;
			while(k&gt;=0){
				if(answer[k]&lt;total[number[k]]-1){
					answer[k]++;
					break;
				}else{
					answer[k]=0;
					k--;
				}
			}
			if(k&lt;0)
				break;
		}
	}
	
	private static void RecursiveSearch(int[] number, int[] answer, int index, int TelLength){	//解法二、递归的方法
		if(index == TelLength){
			for(int i=0; i&lt;TelLength; i++){
				System.out.print(c[number[i]][answer[i]]);
			}
			System.out.println(&quot;&quot;);
			return;
		}
		for(answer[index]=0; answer[index]&lt;total[number[index]]; answer[index]++){
			RecursiveSearch(number, answer, index+1, TelLength);
		}
	}
	
	public static void main(String args[]){
		String phoneNum=&quot;5869872&quot;;
		Num2Letter.PrintResult(phoneNum);
	}
}
</code></pre>
<h1 id="题目2">题目2</h1>
<p>解法1：直接把电话号码所对应的字符串匹配字典<br>
解法2：把字典里所有单词转化为数字</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[连续自然数的加法]]></title>
        <id>https://tienyeung.github.io/post/lian-xu-zi-ran-shu-de-jia-fa</id>
        <link href="https://tienyeung.github.io/post/lian-xu-zi-ran-shu-de-jia-fa">
        </link>
        <updated>2019-10-21T02:18:59.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><strong>问题1</strong>：写一个程序，对于一个64位正整数，输出它所有可能的连续自然数（两个以上）之和的算式.<br>
<strong>问题2</strong>：大家在测试上面程序的过程中，肯定会注意到有一些数字不能表达为一系列连续的自然之和，例如32好像就找不到。那么，这样的数字有什么规律呢？能否证明你的结论？<br>
<strong>问题3</strong>:在64位正整数范围内，子序列数目最多的数是哪一个？这个问题要用程序蛮力搜索，恐怕要运行很长时间，能否用数学知识推导出来？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><strong>问题1</strong>：写一个程序，对于一个64位正整数，输出它所有可能的连续自然数（两个以上）之和的算式.<br>
<strong>问题2</strong>：大家在测试上面程序的过程中，肯定会注意到有一些数字不能表达为一系列连续的自然之和，例如32好像就找不到。那么，这样的数字有什么规律呢？能否证明你的结论？<br>
<strong>问题3</strong>:在64位正整数范围内，子序列数目最多的数是哪一个？这个问题要用程序蛮力搜索，恐怕要运行很长时间，能否用数学知识推导出来？</p>
</blockquote>
<!-- more -->
<h1 id="解法1">解法1</h1>
<p>如果sum = a + (a+1) + (a+2)...+(a+n-1)<br>
对于给定的n, a=(sum-n(n-1)/2)/n 若a为整数就成立，输出<br>
n的范围，最小是2, 最大是a=0时  n(n-1)/2=sum  n&lt;sqrt(2sum)+1</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

void getAllContinuousNum()
{
    int sum;
    scanf(&quot;%ul\n&quot;, &amp;sum);

    int maxlength = sqrt(double(sum) * 2) + 1;
    int firstnum = 0;
    for(int length = 2; length &lt; maxlength; length++) //对数字的个数循环
    {
        if((sum - length * (length - 1) / 2)% length == 0) //可以得到解
        {
            firstnum = (sum - length * (length - 1) / 2) / length;
            printf(&quot;%d=%d&quot;, sum, firstnum);
            for(int num = firstnum + 1, i = 1; i &lt; length; i++, num ++ )
            {
                printf(&quot;+%d&quot;, num);
            }
            printf(&quot;\n&quot;);    
        }
    }
}

int main()
{
    for(int i = 0; i &lt; 10; i++)
    {
        getAllContinuousNum();
    }
    return 0;
}
</code></pre>
<h1 id="解法2">解法2</h1>
<h2 id="解答1">解答1</h2>
<p>首先分析，<br>
对于正整数N，如果表示成2个连续自然数相加，N = m + (m + 1) = 2m + 1，则N为奇数；<br>
如果表示成3个连续的自然数相加，N = (m - 1) + m + (m + 1) = 3m，则N为3的倍数；<br>
如果表示成4个连续的自然数相加，N = (m - 1) + m + (m + 1) + (m + 2) = 2 * (2m + 1)，则N为某奇数的2倍；<br>
如果表示成5个连续的自然数相加，……，则N为5的倍数；<br>
如果表示成5个连续的自然数相加，……，则N为某奇数的3倍；<br>
……<br>
已经找到规律了：对于N，<br>
如果表示成偶数个(2 * k) 连续的自然数相加，      则N为k的倍数；<br>
如果表示成奇数个(2 * k + 1)连续的自然数相加， 则N为(2 * k + 1)的倍数</p>
<pre><code class="language-c">#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

bool AddSubN(__int64 N)
{
	if(N &lt; 3)
	{
		printf(&quot;No sequences fit N./n&quot;);
		return false;
	}
	bool bFind = false;
	int num = 0;
	printf(&quot;/n %I64d ./n&quot;, N);

	__int64 maxLoop = sqrt(2 * N);
	//当N = 1 + 2 + ... + m = m * (m + 1) / 2时的序列长度最大，
	//所以maxLoop比这个小
	//注意：这里可能得用大整数开方，我懒得写了

	__int64 i, j, testN;
			// 看N是否能被表达成 i 个连续自然数之和
	for(i = 2; i &lt;= maxLoop; i ++)
	{
		if(!(i &amp; 0x1))	//如果 i 是偶数，则N为 i/2 的倍数，且 N /(i/2) 为奇数；
		{
			if((!(N % (i &gt;&gt; 1))) &amp;&amp; ((N / (i &gt;&gt; 1))) &amp; 1)
			{
				__int64 sub0 = (N / (i &gt;&gt; 1) - 1) / 2;	// i 个数中，中间偏左的一个
				sub0 -= i / 2 - 1;						// i 个数中最左边的一个
				testN = 0;
				for(j = 0; j &lt; i; j ++)
					testN += sub0 + j;
					//打印出来，测试是否跟输入的N一样
				printf(&quot;/n %I64d = &quot;, N, testN);

					//打印连续自然数序列
				for(j = 0; j &lt; i - 1; j ++)
					printf(&quot;%I64d + &quot;, sub0 + j);
				printf(&quot;%I64d ./n&quot;, sub0 + j);

				if(!bFind)
					bFind = true;
				num ++;

			}
		}
		else		// 如果 i 是奇数，则N为 i 的倍数
		{
			if(!(N % i))
			{
				__int64 sub0 = N / i;
				sub0 -= i / 2;			//找到i个数中最左边的一个

				testN = 0;
				for(j = 0; j &lt; i; j ++)
					testN += sub0 + j;
				//打印出来，测试是否跟输入的N一样
				printf(&quot;/n %I64d = &quot;, N, testN);
				
				//打印连续自然数序列
				for(j = 0; j &lt; i - 1; j ++)
					printf(&quot;%I64d + &quot;, sub0 + j);
				printf(&quot;%I64d ./n&quot;, sub0 + j);
				
				if(!bFind)
					bFind = true;

				num ++;
			}
		}
	}
	if(!bFind)
	{
		printf(&quot;No sequences fit N./n&quot;);
		return false;
	}

	printf(&quot;/n---------------/n %d sequences fit N found ./n&quot;, num);

	return true;
}

void main()
{
	__int64 N = 3;
	while(N &gt;= 1)
	{
		printf(&quot;Please input a int64 number. (input 0 or -1 to escape)/n&quot;);
		scanf(&quot;%I64d&quot;, &amp;N);
		system(&quot;cls&quot;);
		AddSubN(N);
		printf(&quot;/n/n/n&quot;);
		system(&quot;pause&quot;);
		system(&quot;cls&quot;);
	}
}
</code></pre>
<hr>
<h2 id="解答2">解答2</h2>
<p>从分析中可以看出，N的因式分解必然要有奇数。证明如下：<br>
a. 首先证明，只要N的因式分解中有奇数，N就能表示为自然数连和。<br>
如果N的因式分解中有奇数，假设为s，且N= k * s<br>
如果k &gt; s/2，则 N可以表示为这个序列的和：k - (s / 2), k - (s / 2) + 1 ... k + (s / 2);<br>
例如 54 = 6 x 9, 可表示为 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10；（6 x 9，偶数为6，则6在这9个自然数的序列的中间）<br>
如果 k &lt; s/2，则N可以表示为这个序列的和：(s + 1)/2 - k, (s+1)/2 - k + 1,..., (s + 1)/2 + k - 1;<br>
如54 = 2 x 27，则可表示为 12 + 13 + 14 + 15；（中间两个数 13 + 14 = 27）</p>
<p>b. 再证明：如果N的因式分解中没有奇数，则N不能表示成连和的形式。<br>
反证：如果能，假设N能表示成k个自然数的连和。<br>
如果k为偶数，设这k个数的中数（中间偏左的一个）为m，将这k个数收尾相加得到k/2个自然数的序列，易证这k/2个自然数都等于2m+1，那么N = (2m + 1) * k / 2，与N的因式分解中没有奇数矛盾；<br>
如果k为奇数，设中数为n，那么N = k * n，与N的因式分解中没有奇数矛盾。</p>
<p>综上，得证。</p>
<hr>
<h2 id="解答3">解答3</h2>
<p>从2的推导过程中想到，将N表达成X<em>Y的形式，Y为奇数（X可以为1），这种表达形式越多，N的连和序列就越多。<br>
这样，将N分解为质因子，例如150 = 2 * 3 * 5 * 5，找到其中所有的奇数，这些奇数能构成的组合数就是N的连和数。<br>
如3，5，5能构成3；5；3</em>5；5<em>5；3</em>5*5，共5种，所以N的连和数也是5个。</p>
<p>再进一步想，已经知道N的质因子分解情况，怎么计算有多少个序列？<br>
例如3<em>5，有3，5，3</em>5，共3种；<br>
而3<em>3</em>5，上面已经说过，共5中；<br>
3<em>3</em>3<em>5，有3，3</em>3，3<em>3</em>3，5，3<em>5，3</em>3<em>5，3</em>3<em>3</em>5，共7种……</p>
<p>总结得到：<br>
假设N的质因子分解中有k种奇数（不是k个）记为odd[1,..,k]，odd[i]有n[i]个，那么N能表示的序列数为：<br>
Ns = (n[0] + 1) * (n[2] + 1) * (n[3] + 1) * ... * (n[k] + 1) - 1</p>
<p>验证：3<em>3</em>3<em>3</em>5<em>5</em>7<em>7</em>7 = 694575，我用程序打印，输出了59个。</p>
<p>这里有4个3，2个5，3个7，(4+1)<em>(2+1)</em>(3+1) - 1 = 60 - 1 = 59，验证成功。而694575乘以2的任意幂次方，所得结果都是59.<br>
接下来就可以思考第三题了：在64位正整数中，子序列数目最多的是哪一个？<br>
已经知道，要求的就是要让子序列数目最多Ns最多，但是64位正整数中“最”多的是谁？首先是一个很大的奇数。<br>
这里我又做一个实验：</p>
<p>3<em>5</em>7*13 = 1365，分解出的连和15个；</p>
<p>3<em>3</em>5<em>5</em>7 = 1575，有17个，</p>
<p>3<em>3</em>3<em>3</em>3*7 = 1701， 有11个；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组分割]]></title>
        <id>https://tienyeung.github.io/post/shu-zu-fen-ge</id>
        <link href="https://tienyeung.github.io/post/shu-zu-fen-ge">
        </link>
        <updated>2019-10-20T01:33:40.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>有一个没有排序、元素个数为2n的正整数数组，要求：如何能把这个数组分割为元素个数为n的两个数组，并使两个子数组的和最接近？题目的本质就是要从2n个整数中找出n个，使得它们的和尽可能地靠近所有整数之和的一半。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>有一个没有排序、元素个数为2n的正整数数组，要求：如何能把这个数组分割为元素个数为n的两个数组，并使两个子数组的和最接近？题目的本质就是要从2n个整数中找出n个，使得它们的和尽可能地靠近所有整数之和的一半。</p>
</blockquote>
<!-- more -->
<h1 id="解法一">解法一</h1>
<p>假设2n个整数之和为SUM。从2n个整数中找出n个元素的和，不管如何接近SUM/2，同样都会存在大于SUM/2或者小于SUM/2的情况。在求解这个问题时，大于或小于SUM/2没有本质的区别。因此，可以只考虑小于等于SUM/2的情况。<br>
比较直观地来说，可以用动态规划来解决这个问题。具体分析如下：<br>
可以把任务分成2N步，第k步的定义是前k个元素中任意i个元素的和，所有可能的取值之集合为Sk（只考虑取值小于等于SUM/2的情况）。<br>
然后将第k步拆分成两个小步。即首先得到前k－1个元素中，任意i个元素，总共能有多少种取值，设这个取值集合为Sk－1＝{vi}。第二步就是令Sk＝Sk－1∪{vi＋arr[k]}，即可完成第k步。<br>
伪代码如下：<br>
<img src="https://i.loli.net/2019/10/20/VnYOhJCNfRrmx12.png" alt="untitled.png" loading="lazy"><br>
从有效性来分析，整个代码是一个三重循环，目的就是执行insert。这个代码实际执行insert的次数至多是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>4</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">4^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>次（枚举所有元素在与不在的情况），因此可以认为复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi mathvariant="normal">（</mi><msup><mn>4</mn><mi>N</mi></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">O（4^N）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span>。<br>
既然算法的时间复杂度是N的指数级，因此在N很大时，效率很低。我们不得不考虑设计一种时间复杂度是N的多项式函数的方法。考虑的出发点是，是否有另一种拆分第k步的方法。</p>
<h1 id="解法二">解法二</h1>
<p>解法二的拆分方法需要遍历Sk－1＝{vi}的元素，由于Sk－1＝{vi}的元素个数随着k的增大而增大，所以导致了解法二的效率低下。能不能设计一个算法使得第k步所花费的时间与k无关呢？<br>
我们不妨倒过来想，原来是给定Sk－1＝{vi}，求Sk。那我们能不能给定Sk的可能值v和arr[k]，去寻找v－arr[k]是否在Sk－1＝{vi}中呢？由于Sk可能值的集合的大小与k无关，所以这样设计的动态规划算法其第k步的时间复杂度与k无关。<br>
代码如下：<br>
<img src="https://i.loli.net/2019/10/20/cISKm6bpYnz48d1.png" alt="untitled1.png" loading="lazy"><br>
利用如上的算法，时间复杂度将为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi mathvariant="normal">（</mi><msup><mi>N</mi><mn>2</mn></msup><mo>∗</mo><mi>S</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">O（N^2* Sum）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">）</span></span></span></span>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最长递增子序列]]></title>
        <id>https://tienyeung.github.io/post/zui-chang-di-zeng-zi-xu-lie</id>
        <link href="https://tienyeung.github.io/post/zui-chang-di-zeng-zi-xu-lie">
        </link>
        <updated>2019-10-20T01:06:07.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>写一个时间复杂度尽可能低的程序，求一个一维数组（N个元素）中的最长递增子序列的长度。根据题目的要求，求一维数组中的最长递增子序列，也就是找一个标号的序列b[0]，b[1]，…，b[m]（0＜＝b[0]＜b[1]＜…＜b[m]＜N），使得array[b[0]]＜array[b[1]]＜…＜array[b[m]]。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>写一个时间复杂度尽可能低的程序，求一个一维数组（N个元素）中的最长递增子序列的长度。根据题目的要求，求一维数组中的最长递增子序列，也就是找一个标号的序列b[0]，b[1]，…，b[m]（0＜＝b[0]＜b[1]＜…＜b[m]＜N），使得array[b[0]]＜array[b[1]]＜…＜array[b[m]]。</p>
</blockquote>
<!-- more -->
<h1 id="解法一">解法一</h1>
<blockquote>
<p>无后效性:将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态来说，它以前各阶段的状态无法直接影响它未来的决策，而只能间接地通过当前的这个状态来影响。换句话说，每个状态都是过去历史的一个完整总结。</p>
</blockquote>
<p>满足无后效性，即可使用动态规划来解决：使用i来表示当前遍历的位置，当i＝2时，由于-1＜1。因此，必须丢弃第一个值然后重新建立串。当前的递增序列为（-1），长度为1。当i＝3时，由于2＞1，2＞-1。因此，最长的递增序列为（1，2），（-1，2），长度为2。在这里，2前面是1还是-1对求出后面的递增序列没有直接影响。<br>
依此类推之后，可以得出如下的结论：<br>
假设在目标数组array[]的前i个元素中，最长递增子序列的长度为LIS[i]。那么，<br>
LIS[i＋1]＝max{1，LIS[k]＋1}，array[i＋1]＞array[k]，for any k＜＝i<br>
即如果array[i＋1]大于array[k]，那么第i＋1个元素可以接在LIS[k]长的子序列后面构成一个更长的子序列。与此同时array[i＋1]本身至少可以构成一个长度为1的子序列。<br>
<img src="https://i.loli.net/2019/10/20/senitVDhpHxkm71.png" alt="untitled.png" loading="lazy"><br>
这种方法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi mathvariant="normal">（</mi><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">O（N^2）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span></p>
<h1 id="解法二">解法二</h1>
<p>找到前i个元素中的一个递增子序列，使得这个递增子序列的最大的元素比array[i＋1]小，且长度尽量地长。这样将array[i＋1]加在该递增子序列后，便可找到以array[i＋1]为最大元素的最长递增子序列。仍然假设在数组的前i个元素中，以array[i]为最大元素的最长递增子序列的长度为LIS[i]。<br>
同时，假设：<br>
长度为1的递增子序列最大元素的最小值为MaxV[1]；<br>
长度为2的递增子序列最大元素的最小值为MaxV[2]；<br>
……<br>
长度为LIS[i]的递增子序列最大元素的最小值为MaxV[LIS[i]]。<br>
<img src="https://i.loli.net/2019/10/20/senitVDhpHxkm71.png" alt="untitled.png" loading="lazy"><br>
时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi mathvariant="normal">（</mi><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">O（N^2）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span><br>
在递增序列中，如果i＜j，那么就会有MaxV[i]＜MaxV[j]。如果出现MaxV[j]＜MaxV[i]的情况，则跟定义矛盾，为什么？<br>
因此，根据这样单调递增的关系，可以将上面方法中的穷举部分进行如下修改：<br>
<img src="https://i.loli.net/2019/10/20/QshFq5vWidKULbR.png" alt="untitled2.png" loading="lazy"><br>
如果把上述的查询部分利用二分搜索进行加速，那么就可以把时间复杂度降为O（N*log2N）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[子数组的最大乘积以及最大和]]></title>
        <id>https://tienyeung.github.io/post/zi-shu-zu-de-zui-da-cheng-ji-yi-ji-zui-da-he</id>
        <link href="https://tienyeung.github.io/post/zi-shu-zu-de-zui-da-cheng-ji-yi-ji-zui-da-he">
        </link>
        <updated>2019-10-19T02:16:29.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>1.给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意（N－1）个数的组合乘积中最大的一组，并写出算法的时间复杂度。<br>
2.一个有N个整数元素的一维数组（A[0]，A[1]，…，A[n－2]，A[n－1]），这个数组当然有很多子数组，那么子数组之和的最大值是什么呢？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>1.给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意（N－1）个数的组合乘积中最大的一组，并写出算法的时间复杂度。<br>
2.一个有N个整数元素的一维数组（A[0]，A[1]，…，A[n－2]，A[n－1]），这个数组当然有很多子数组，那么子数组之和的最大值是什么呢？</p>
</blockquote>
<!-- more -->
<h1 id="子数组的最大乘积">子数组的最大乘积</h1>
<p>假设N个整数的乘积为P，针对P的正负性进行如下分析（其中，AN－1表示N－1个数的组合，PN－1表示N－1个数的组合的乘积）：</p>
<ol>
<li>P为0<br>
那么，数组中至少包含有一个0。假设除去一个0之外，其他N－1个数的乘积为Q，根据Q的正负性进行讨论：<br>
Q为0<br>
说明数组中至少有两个0，那么N－1个数的乘积只能为0，返回0；<br>
Q为正数<br>
返回Q，因为如果以0替换此时AN－1中的任一个数，所得到的PN－1为0，必然小于Q；<br>
Q为负数<br>
如果以0替换此时AN－1中的任一个数，所得到的PN－1为0，大于Q，乘积最大值为0。</li>
<li>P为负数<br>
根据“负负得正”的乘法性质，自然想到从N个整数中去掉一个负数，使得PN－1为一个正数。而要使这个正数最大，这个被去掉的负数的绝对值必须是数组中最小的。我们只需要扫描一遍数组，把绝对值最小的负数给去掉就可以了。</li>
<li>P为正数<br>
类似P为负数的情况，应该去掉一个绝对值最小的正数值，这样得到的PN－1就是最大的。<br>
上面的解法采用了直接求N个整数的乘积P，进而判断P的正负性的办法，但是直接求乘积在编译环境下往往会有溢出的危险（这也就是本题要求不使用除法的潜在用意），事实上可做一个小的转变，<strong>不需要直接求乘积，而是求出数组中正数（+）、负数（-）和0的个数，从而判断P的正负性，其余部分与以上面的解法相同</strong>。<br>
在时间复杂度方面，由于只需要遍历数组一次，在遍历数组的同时就可得到数组中正数（+）、负数（-）和0的个数，以及数组中绝对值最小的正数和负数，时间复杂度为O（N）。</li>
</ol>
<pre><code class="language-java">public int findMaxProduct2(int[] A) {
        int np = 0, nn = 0, nz = 0; // 数组A中正数的个数，负数的个数，0的个数
        int min_abs_pv = Integer.MAX_VALUE, min_abs_nv = Integer.MAX_VALUE; // 数组中绝对值最小的正数和负数
        int max_abs_nv = 0; // 数组中绝对值最大的负数
        for (int i = 0; i &lt; A.length; ++i) {
            if (A[i] &gt; 0) {
                ++np;
                min_abs_pv = min_abs_pv &gt; A[i] ? A[i] : min_abs_pv;
            } else if (A[i] &lt; 0) {
                ++nn;
                min_abs_nv = min_abs_nv &gt; -A[i] ? -A[i] : min_abs_nv;
                max_abs_nv = max_abs_nv &lt; -A[i] ? -A[i] : max_abs_nv;
            } else ++nz;


        }

        if (nz &gt;= 2) return 0;

        int signOfP = 0;
        if (nn % 2 == 0) signOfP = 1;
        else signOfP = -1;

        int maxPro = 1;
        if (signOfP == 0) {
            for (int i = 0; i &lt; A.length; ++i) {
                if (A[i] != 0) maxPro *= A[i];
            }
            return maxPro &gt; 0 ? maxPro : 0;
        } else if (signOfP == -1) {
            for (int i = 0; i &lt; A.length; ++i) {
                if (!(A[i]&lt;0 &amp;&amp; Math.abs(A[i]) == min_abs_nv)) // 去掉绝对值最大负数
                    maxPro *= A[i];
            }
            return maxPro;
        } else { // P为正数
            if (np &gt; 0) { // 数组中存在正数
                for (int i = 0; i &lt; A.length; ++i) {
                    if (!(A[i]&gt;0 &amp;&amp; A[i] != min_abs_pv))
                        maxPro *= A[i];
                }
                return maxPro;
            } else {// 数组中不存在正数
                for (int i = 0; i &lt; A.length; ++i) {
                    if (!(A[i]&lt;0 &amp;&amp; Math.abs(A[i]) == max_abs_nv))
                        maxPro *= A[i];
                }
                return maxPro;
            }
        }
}
</code></pre>
<h1 id="子数组之和的最大值">★子数组之和的最大值</h1>
<p>明确题意：</p>
<ul>
<li>题目说的子数组，是连续的。</li>
<li>题目只需要求和，并不需要返回子数组的具体位置。</li>
<li>数组的元素是整数，所以数组可能包含有正整数、零、负整数。</li>
</ul>
<p><em>这道题同样可以求解股票的何时买进何时卖出得以利益最大化的问题</em></p>
<h2 id="解法一-on2">解法一 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h2>
<pre><code class="language-python">def maxsum(A:list):
    maxinum=float(&quot;-inf&quot;)
    for i in range(A):
        j=i
        for j in range(A):
            sum+=A[j]
            if sum&gt;maxinum:
                maximun=sum
    return sum
</code></pre>
<h2 id="解法二-onlog2n">解法二 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*log2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h2>
<p>如果将所给数组（A[0]，…，A[n－1]）分为长度相等的两段数组（A[0]，…，A[n/2－1]）和（A[n/2]，…，A[n－1]），分别求出这两段数组各自的最大子段和，则原数组（A[0]，…，A[n－1]）的最大子段和为以下三种情况的最大值：</p>
<ol>
<li>（A[0]，…，A[n－1]）的最大子段和与（A[0]，…，A[n/2－1]）的最大子段和相同。</li>
<li>（A[0]，…，A[n－1]）的最大子段和与（A[n/2]，…，A[n－1]）的最大子段和相同。</li>
<li>（A[0]，…，A[n－1]）的最大子段跨过其中间两个元素A[n/2－1]到A[n/2]。</li>
</ol>
<p>1和2两种情况事实上是问题规模减半的相同子问题，可以通过递归求得。至于第3种情况，我们只要找到以A[n/2－1]结尾的和最大的一段数组和s1＝（A[i]，…，A[n/2－1]）（0＜＝i＜n/2－1）A[]和以A[n/2]开始和最大的一段和s2＝（A[n/2]，…，A[j]）（n/2＜＝j＜n）。那么第3种情况的最大值为s1＋s2＝A[i]＋…＋A[n/2－1]＋A[n/2]＋…＋A[j]，只需要对原数组进行一次遍历即可。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

#define N 1001

int array[N];

int MaxSubsequence(int L,int R){
    int i,j;
    //0个元素
    if(L &gt; R){
        return 0;
    }
    //1个元素
    if(L == R){
        return array[L];
    }
    int mid = (L + R) / 2;
    //跨越a和b之间的部分
    //在a中的部分是a中包含右边界的最大子数组
    int sum = 0;
    int leftMax = array[mid];
    for(i = mid;i &gt;= L;i--){
        sum += array[i];
        leftMax = max(leftMax,sum);
    }
    //在b中的部分是b中包含左边界的最大子数组
    sum = 0;
    int rightMax = array[mid+1];
    for(i = mid+1;i &lt;= R;i++){
        sum += array[i];
        rightMax = max(rightMax,sum);
    }
    //递归调用
    //跨越a和b
    int maxSum = rightMax+leftMax;
    //整个在a中
    maxSum = max(maxSum,MaxSubsequence(L,mid));
    //整个在b中
    maxSum = max(maxSum,MaxSubsequence(mid+1,R));
    return maxSum;
}

int main(){
    int n,i,j;
    //freopen(&quot;C:\\Users\\XIAOSI\\Desktop\\acm.txt&quot;,&quot;r&quot;,stdin);
    while(scanf(&quot;%d&quot;,&amp;n) != EOF){
        //输入数据
        for(i = 0;i &lt; n;i++){
            scanf(&quot;%d&quot;,&amp;array[i]);
        }
        int maxSum = MaxSubsequence(0,n-1);
        printf(&quot;%d\n&quot;,maxSum);
    }
    return 0;
}
</code></pre>
<h2 id="解法三-on">解法三 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h2>
<p>使用动态规划的方法，考虑数组第一个元素arr[0]，以及和最大的子数组[i, j]之间的关系，有以下三种情况：<br>
1．当0＝i＝j时，元素A[0]本身构成和最大的一段；<br>
2．当0＝i＜j时，和最大的一段以A[0]开始；<br>
3．当0＜i时，元素A[0]跟和最大的一段没有关系。<br>
从上面三种情况可以看出，可以将一个大问题（N个元素数组）转化为一个较小的问题（n－1个元素的数组）。假设已经知道（A[1]，…，A[n－1]）中和最大的一段之和为All[1]，并且已经知道（A[1]，…，A[n－1]）中包含A[1]的和最大的一段的和为Start[1]。那么，根据上述分析的三种情况，不难看出（A[0]，…，A[n－1]）中问题的解All[0]是三种情况的最大值max{A[0]，A[0]＋Start[1]，All[1]}。通过这样的分析，可以看出这个问题符合无后效性，可以使用动态规划的方法来解决.</p>
<pre><code class="language-c">int max(int x, int y)
{
    return x &gt; y ? x : y;
} 

int maxSum(int *arr, int n)
{
    int start[n - 1] = arr[n - 1];
    int all[n - 1] = arr[n - 1];
    for(int i = n - 2; i &gt;= 0; i--)//必须从后往前遍历数组
    {
        start[i] = max(arr[i], arr[i] + start[i + 1]);
        all[i] = max(start[i], all[i + 1]); 
    }
    return all[0];
</code></pre>
<p>空间上对其进行优化，可以使用两个变量代替使用两个数组。第一个递推式：Start[i]＝max{A[i]，Start[i＋1]＋A[i]}。如果Start[i＋1]＜0，则Start[i]＝A[i]。而且，在这两个递推式中，其实都只需要用两个变量就可以了。Start[k＋1]只有在计算Start[k]时使用，而All[k＋1]也只有在计算All[k]时使用。所以程序可以进一步改进一下，只需O（1）的空间就足够了。</p>
<pre><code class="language-c">int max(int x, int y)
{
    return x &gt; y ? x : y;
} 

int maxSum(int *arr, int n)
{
    int start = arr[n - 1];
    int all = arr[n - 1];
    for(int i = n - 2; i &gt;= 0; i--)
    {
        start = max(arr[i], arr[i] + start);
        all = max(start, all);  
    }
    return all;
}
</code></pre>
<p>我们还可以换一个写法：<br>
<img src="https://i.loli.net/2019/10/19/OL7eFglM2BK8NnC.png" alt="untitled.png" loading="lazy"></p>
]]></content>
    </entry>
</feed>