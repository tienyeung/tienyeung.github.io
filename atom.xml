<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tienyeung.github.io/</id>
    <title>阳阳の部落格</title>
    <updated>2019-10-19T03:19:20.623Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tienyeung.github.io/"/>
    <link rel="self" href="https://tienyeung.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://tienyeung.github.io//images/avatar.png</logo>
    <icon>https://tienyeung.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 阳阳の部落格</rights>
    <entry>
        <title type="html"><![CDATA[子数组的最大乘积以及最大和]]></title>
        <id>https://tienyeung.github.io//post/zi-shu-zu-de-zui-da-cheng-ji-yi-ji-zui-da-he</id>
        <link href="https://tienyeung.github.io//post/zi-shu-zu-de-zui-da-cheng-ji-yi-ji-zui-da-he">
        </link>
        <updated>2019-10-19T02:16:29.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>1.给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意（N－1）个数的组合乘积中最大的一组，并写出算法的时间复杂度。<br>
2.一个有N个整数元素的一维数组（A[0]，A[1]，…，A[n－2]，A[n－1]），这个数组当然有很多子数组，那么子数组之和的最大值是什么呢？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>1.给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意（N－1）个数的组合乘积中最大的一组，并写出算法的时间复杂度。<br>
2.一个有N个整数元素的一维数组（A[0]，A[1]，…，A[n－2]，A[n－1]），这个数组当然有很多子数组，那么子数组之和的最大值是什么呢？</p>
</blockquote>
<!-- more -->
<h1 id="子数组的最大乘积">子数组的最大乘积</h1>
<p>假设N个整数的乘积为P，针对P的正负性进行如下分析（其中，AN－1表示N－1个数的组合，PN－1表示N－1个数的组合的乘积）：</p>
<ol>
<li>P为0<br>
那么，数组中至少包含有一个0。假设除去一个0之外，其他N－1个数的乘积为Q，根据Q的正负性进行讨论：<br>
Q为0<br>
说明数组中至少有两个0，那么N－1个数的乘积只能为0，返回0；<br>
Q为正数<br>
返回Q，因为如果以0替换此时AN－1中的任一个数，所得到的PN－1为0，必然小于Q；<br>
Q为负数<br>
如果以0替换此时AN－1中的任一个数，所得到的PN－1为0，大于Q，乘积最大值为0。</li>
<li>P为负数<br>
根据“负负得正”的乘法性质，自然想到从N个整数中去掉一个负数，使得PN－1为一个正数。而要使这个正数最大，这个被去掉的负数的绝对值必须是数组中最小的。我们只需要扫描一遍数组，把绝对值最小的负数给去掉就可以了。</li>
<li>P为正数<br>
类似P为负数的情况，应该去掉一个绝对值最小的正数值，这样得到的PN－1就是最大的。<br>
上面的解法采用了直接求N个整数的乘积P，进而判断P的正负性的办法，但是直接求乘积在编译环境下往往会有溢出的危险（这也就是本题要求不使用除法的潜在用意），事实上可做一个小的转变，<strong>不需要直接求乘积，而是求出数组中正数（+）、负数（-）和0的个数，从而判断P的正负性，其余部分与以上面的解法相同</strong>。<br>
在时间复杂度方面，由于只需要遍历数组一次，在遍历数组的同时就可得到数组中正数（+）、负数（-）和0的个数，以及数组中绝对值最小的正数和负数，时间复杂度为O（N）。</li>
</ol>
<pre><code class="language-java">public int findMaxProduct2(int[] A) {
        int np = 0, nn = 0, nz = 0; // 数组A中正数的个数，负数的个数，0的个数
        int min_abs_pv = Integer.MAX_VALUE, min_abs_nv = Integer.MAX_VALUE; // 数组中绝对值最小的正数和负数
        int max_abs_nv = 0; // 数组中绝对值最大的负数
        for (int i = 0; i &lt; A.length; ++i) {
            if (A[i] &gt; 0) {
                ++np;
                min_abs_pv = min_abs_pv &gt; A[i] ? A[i] : min_abs_pv;
            } else if (A[i] &lt; 0) {
                ++nn;
                min_abs_nv = min_abs_nv &gt; -A[i] ? -A[i] : min_abs_nv;
                max_abs_nv = max_abs_nv &lt; -A[i] ? -A[i] : max_abs_nv;
            } else ++nz;


        }

        if (nz &gt;= 2) return 0;

        int signOfP = 0;
        if (nn % 2 == 0) signOfP = 1;
        else signOfP = -1;

        int maxPro = 1;
        if (signOfP == 0) {
            for (int i = 0; i &lt; A.length; ++i) {
                if (A[i] != 0) maxPro *= A[i];
            }
            return maxPro &gt; 0 ? maxPro : 0;
        } else if (signOfP == -1) {
            for (int i = 0; i &lt; A.length; ++i) {
                if (!(A[i]&lt;0 &amp;&amp; Math.abs(A[i]) == min_abs_nv)) // 去掉绝对值最大负数
                    maxPro *= A[i];
            }
            return maxPro;
        } else { // P为正数
            if (np &gt; 0) { // 数组中存在正数
                for (int i = 0; i &lt; A.length; ++i) {
                    if (!(A[i]&gt;0 &amp;&amp; A[i] != min_abs_pv))
                        maxPro *= A[i];
                }
                return maxPro;
            } else {// 数组中不存在正数
                for (int i = 0; i &lt; A.length; ++i) {
                    if (!(A[i]&lt;0 &amp;&amp; Math.abs(A[i]) == max_abs_nv))
                        maxPro *= A[i];
                }
                return maxPro;
            }
        }
}
</code></pre>
<h1 id="子数组之和的最大值">★子数组之和的最大值</h1>
<p>明确题意：</p>
<ul>
<li>题目说的子数组，是连续的。</li>
<li>题目只需要求和，并不需要返回子数组的具体位置。</li>
<li>数组的元素是整数，所以数组可能包含有正整数、零、负整数。</li>
</ul>
<h2 id="解法一-on2">解法一 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h2>
<pre><code class="language-python">def maxsum(A:list):
    maxinum=float(&quot;-inf&quot;)
    for i in range(A):
        j=i
        for j in range(A):
            sum+=A[j]
            if sum&gt;maxinum:
                maximun=sum
    return sum
</code></pre>
<h2 id="解法二-onlog2n">解法二 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*log2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h2>
<p>如果将所给数组（A[0]，…，A[n－1]）分为长度相等的两段数组（A[0]，…，A[n/2－1]）和（A[n/2]，…，A[n－1]），分别求出这两段数组各自的最大子段和，则原数组（A[0]，…，A[n－1]）的最大子段和为以下三种情况的最大值：</p>
<ol>
<li>（A[0]，…，A[n－1]）的最大子段和与（A[0]，…，A[n/2－1]）的最大子段和相同。</li>
<li>（A[0]，…，A[n－1]）的最大子段和与（A[n/2]，…，A[n－1]）的最大子段和相同。</li>
<li>（A[0]，…，A[n－1]）的最大子段跨过其中间两个元素A[n/2－1]到A[n/2]。</li>
</ol>
<p>1和2两种情况事实上是问题规模减半的相同子问题，可以通过递归求得。至于第3种情况，我们只要找到以A[n/2－1]结尾的和最大的一段数组和s1＝（A[i]，…，A[n/2－1]）（0＜＝i＜n/2－1）A[]和以A[n/2]开始和最大的一段和s2＝（A[n/2]，…，A[j]）（n/2＜＝j＜n）。那么第3种情况的最大值为s1＋s2＝A[i]＋…＋A[n/2－1]＋A[n/2]＋…＋A[j]，只需要对原数组进行一次遍历即可。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

#define N 1001

int array[N];

int MaxSubsequence(int L,int R){
    int i,j;
    //0个元素
    if(L &gt; R){
        return 0;
    }
    //1个元素
    if(L == R){
        return array[L];
    }
    int mid = (L + R) / 2;
    //跨越a和b之间的部分
    //在a中的部分是a中包含右边界的最大子数组
    int sum = 0;
    int leftMax = array[mid];
    for(i = mid;i &gt;= L;i--){
        sum += array[i];
        leftMax = max(leftMax,sum);
    }
    //在b中的部分是b中包含左边界的最大子数组
    sum = 0;
    int rightMax = array[mid+1];
    for(i = mid+1;i &lt;= R;i++){
        sum += array[i];
        rightMax = max(rightMax,sum);
    }
    //递归调用
    //跨越a和b
    int maxSum = rightMax+leftMax;
    //整个在a中
    maxSum = max(maxSum,MaxSubsequence(L,mid));
    //整个在b中
    maxSum = max(maxSum,MaxSubsequence(mid+1,R));
    return maxSum;
}

int main(){
    int n,i,j;
    //freopen(&quot;C:\\Users\\XIAOSI\\Desktop\\acm.txt&quot;,&quot;r&quot;,stdin);
    while(scanf(&quot;%d&quot;,&amp;n) != EOF){
        //输入数据
        for(i = 0;i &lt; n;i++){
            scanf(&quot;%d&quot;,&amp;array[i]);
        }
        int maxSum = MaxSubsequence(0,n-1);
        printf(&quot;%d\n&quot;,maxSum);
    }
    return 0;
}
</code></pre>
<h2 id="解法三-on">解法三 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h2>
<p>使用动态规划的方法，考虑数组第一个元素arr[0]，以及和最大的子数组[i, j]之间的关系，有以下三种情况：<br>
1．当0＝i＝j时，元素A[0]本身构成和最大的一段；<br>
2．当0＝i＜j时，和最大的一段以A[0]开始；<br>
3．当0＜i时，元素A[0]跟和最大的一段没有关系。<br>
从上面三种情况可以看出，可以将一个大问题（N个元素数组）转化为一个较小的问题（n－1个元素的数组）。假设已经知道（A[1]，…，A[n－1]）中和最大的一段之和为All[1]，并且已经知道（A[1]，…，A[n－1]）中包含A[1]的和最大的一段的和为Start[1]。那么，根据上述分析的三种情况，不难看出（A[0]，…，A[n－1]）中问题的解All[0]是三种情况的最大值max{A[0]，A[0]＋Start[1]，All[1]}。通过这样的分析，可以看出这个问题符合无后效性，可以使用动态规划的方法来解决.</p>
<pre><code class="language-c">int max(int x, int y)
{
    return x &gt; y ? x : y;
} 

int maxSum(int *arr, int n)
{
    int start[n - 1] = arr[n - 1];
    int all[n - 1] = arr[n - 1];
    for(int i = n - 2; i &gt;= 0; i--)//必须从后往前遍历数组
    {
        start[i] = max(arr[i], arr[i] + start[i + 1]);
        all[i] = max(start[i], all[i + 1]); 
    }
    return all[0];
</code></pre>
<p>空间上对其进行优化，可以使用两个变量代替使用两个数组。第一个递推式：Start[i]＝max{A[i]，Start[i＋1]＋A[i]}。如果Start[i＋1]＜0，则Start[i]＝A[i]。而且，在这两个递推式中，其实都只需要用两个变量就可以了。Start[k＋1]只有在计算Start[k]时使用，而All[k＋1]也只有在计算All[k]时使用。所以程序可以进一步改进一下，只需O（1）的空间就足够了。</p>
<pre><code class="language-c">int max(int x, int y)
{
    return x &gt; y ? x : y;
} 

int maxSum(int *arr, int n)
{
    int start = arr[n - 1];
    int all = arr[n - 1];
    for(int i = n - 2; i &gt;= 0; i--)
    {
        start = max(arr[i], arr[i] + start);
        all = max(start, all);  
    }
    return all;
}
</code></pre>
<p>我们还可以换一个写法：<br>
<img src="https://i.loli.net/2019/10/19/OL7eFglM2BK8NnC.png" alt="untitled.png"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[寻找数组中最大值和最小值]]></title>
        <id>https://tienyeung.github.io//post/xun-zhao-shu-zu-zhong-zui-da-zhi-he-zui-xiao-zhi</id>
        <link href="https://tienyeung.github.io//post/xun-zhao-shu-zu-zhong-zui-da-zhi-he-zui-xiao-zhi">
        </link>
        <updated>2019-10-18T02:49:00.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>数组是最简单的一种数据结构。我们经常碰到的一个基本问题，就是寻找整个数组中最大的数，或者最小的数。这时，我们都会扫描一遍数组，把最大（最小）的数找出来。如果我们需要<strong>同时</strong>找出最大和最小的数呢？对于一个由N个整数组成的数组，需要比较多少次才能把最大和最小的数找出来呢？</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>数组是最简单的一种数据结构。我们经常碰到的一个基本问题，就是寻找整个数组中最大的数，或者最小的数。这时，我们都会扫描一遍数组，把最大（最小）的数找出来。如果我们需要<strong>同时</strong>找出最大和最小的数呢？对于一个由N个整数组成的数组，需要比较多少次才能把最大和最小的数找出来呢？</p>
</blockquote>
<!-- more -->
<p>最简单的无非是扫描两次数组，分别找出最大值和最小值，但能否将这二者看似独立的问题建立关联，从而减少比较次数呢？</p>
<h1 id="解法一">解法一</h1>
<p>一般情况下，最大的数和最小的数不会是同一个数（除非N＝1，或者所有整数都是一样的大小）。所以，我们希望先把数组分成两部分，然后再从这两部分中分别找出最大的数和最小的数。首先按顺序将数组中相邻的两个数分在同一组（这只是概念上的分组，无须做任何实际操作）。若数组为{5，6，8，3，7，9} 如图所示：<br>
<img src="https://i.loli.net/2019/10/18/ra7P2sbJ9RLKoHv.png" alt="untitled.png"><br>
接着比较同一组中奇数位数字和偶数位数字，将较大的数放在偶数位上，较小的数放在奇数位上。经过N/2次比较的预处理后，较大的数都放到了偶数位置上，较小的数则放到了奇数位置上，如图：<br>
<img src="https://i.loli.net/2019/10/18/Cfx14NSLBpVte6F.png" alt="untitled1.png"><br>
最后，我们从奇偶数位上分别求出Max＝9，Min＝3，各需要比较N/2次。整个算法共需要比较1.5*N次。<br>
如此 <strong>2*N --&gt; 1.5*N</strong></p>
<h1 id="解法二">解法二</h1>
<p>在解法一基础上改进，无需破坏数组。首先仍然按顺序将数组中相邻的两个数分在同一组，然后可以利用两个变量Max和Min来存储当前的最大值和最小值。。同一组的两个数比较之后，不再调整顺序，而是将其中较小的数与当前Min作比较，如果该数小于当前Min则更新Min。同理，将其中较大的数与当前Max作比较，如果该数大于当前Max，则更新Max。如此反复比较，直到遍历完整个数组。Min和Max分别被初始化为数组第一和第二个数中的小者和大者。比较次数仍为1.5*N次。</p>
<h1 id="解法三">解法三</h1>
<p>分治思想是算法中很常用的一种技巧。在N个数中求最小值Min和最大值Max，我们只须分别求出前后N/2个数的Min和Max，然后取较小的Min，较大的Max即可（只须较大的数和较大的数比较，较小的数和较小的数比较，两次就可以了）。但即使采用分治法，总的比较次数仍然没有减少。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波那契数列的优化]]></title>
        <id>https://tienyeung.github.io//post/fei-bo-na-qi-shu-lie-de-you-hua</id>
        <link href="https://tienyeung.github.io//post/fei-bo-na-qi-shu-lie-de-you-hua">
        </link>
        <updated>2019-10-18T02:13:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>斐波那契数列是一个非常美丽、和谐的数列，有人说它起源于一对繁殖力惊人、基因非常优秀的兔子，也有人说远古时期的鹦鹉螺就知道这个规律。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>斐波那契数列是一个非常美丽、和谐的数列，有人说它起源于一对繁殖力惊人、基因非常优秀的兔子，也有人说远古时期的鹦鹉螺就知道这个规律。</p>
</blockquote>
<!-- more -->
<h1 id="常规递归法">常规递归法</h1>
<pre><code class="language-python">def Fibonacci(n):
    if n&lt;=0:
        return 0
    elif n == 1:
        return 1
    else:
        return  Fibonacci(n-1)+Fibonacci(n-2)
</code></pre>
<p>思考一下，能否将其效率进一步优化，递归法其中涉及到许多重复计算，而如何减少这些计算呢？可以用数组储存所有已计算过的项，这样便可以达到空间换时间的目的。但是否有更快的算法呢？</p>
<h1 id="更快的算法">更快的算法</h1>
<h2 id="通项公式">通项公式</h2>
<p>由递推公式F（n）＝F（n－1）＋F（n－2），知道F(n)的特征方程为：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mi mathvariant="normal">＝</mi><mi>x</mi><mi mathvariant="normal">＋</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x^2＝x＋1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">＝</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">＋</span><span class="mord">1</span></span></span></span><br>
有根：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow></msub><mo>=</mo><mfrac><mrow><mn>1</mn><mo>±</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">X_{1,2}=\frac{1\pm \sqrt{5}}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">±</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
所以存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>A</mi><mo>∗</mo><mo>(</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><msup><mo>)</mo><mi>n</mi></msup><mo>+</mo><mi>B</mi><mo>∗</mo><mo>(</mo><mfrac><mrow><mn>1</mn><mo>−</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><msup><mo>)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">F(n)=A*(\frac{1+\sqrt{5}}{2})^n+B*(\frac{1-\sqrt{5}}{2})^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span><br>
代入F（0）＝0，F（1）＝1<br>
可解得A,B,之后用通项公式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mfrac><msqrt><mn>5</mn></msqrt><mn>5</mn></mfrac><mo>∗</mo><mo>(</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><msup><mo>)</mo><mi>n</mi></msup><mo>−</mo><mfrac><msqrt><mn>5</mn></msqrt><mn>5</mn></mfrac><mo>∗</mo><mo>(</mo><mfrac><mrow><mn>1</mn><mo>−</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><msup><mo>)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">F(n)=\frac{\sqrt{5}}{5}*(\frac{1+\sqrt{5}}{2})^n-\frac{\sqrt{5}}{5}*(\frac{1-\sqrt{5}}{2})^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>即可得,但其中引入了无理数，不能保证结果精度。</p>
<h2 id="分治策略">分治策略</h2>
<p>注意到Fibonacci数列是二阶递推数列，所以存在一个2*2的矩阵A，使得：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>F</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>F</mi><mi>n</mi></msub><mo>−</mo><mn>1</mn><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>F</mi><mi>n</mi></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>F</mi><mi>n</mi></msub><mo>−</mo><mn>2</mn><mo>)</mo><mo>∗</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">(F_n,F_n-1)=(F_n-1,F_n-2)*A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>,可解得A:<br>
可解得A=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\begin{matrix}
   1 &amp; 1 \\
   1 &amp; 0 \\
  \end{matrix}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span><br>
于是，推广：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>F</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>F</mi><mi>n</mi></msub><mo>−</mo><mn>1</mn><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>F</mi><mi>n</mi></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>F</mi><mi>n</mi></msub><mo>−</mo><mn>2</mn><mo>)</mo><mo>∗</mo><mi>A</mi><mo>=</mo><mo>(</mo><msub><mi>F</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>F</mi><mn>0</mn></msub><mo>)</mo><mo>∗</mo><msup><mi>A</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(F_n,F_n-1)=(F_n-1,F_n-2)*A=(F_1,F_0)*A^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><br>
接下来，如何求解n个A矩阵的乘法就值得思考，我们可以用二进制来表示A的指数:<br>
<img src="https://i.loli.net/2019/10/18/Lf6rGIdUJZSixkC.png" alt="untitled.png"><br>
举个栗子：<br>
<img src="https://i.loli.net/2019/10/18/Xn2YK4IwRgBJfEH.png" alt="untitled1.png"><br>
<img src="https://i.loli.net/2019/10/18/nNP8imOsHfUFzZ9.png" alt="untitled2.png"><br>
<img src="https://i.loli.net/2019/10/18/TylWaiK5n9kod1u.png" alt="untitled5.png"><br>
<img src="https://i.loli.net/2019/10/18/NDqbfQgBYTpGew6.png" alt="untitled3.png"><br>
于是，复杂度为O(logn)的算法如下：<br>
<img src="https://i.loli.net/2019/10/18/yPFfvVcol1bQUIJ.png" alt="untitled4.png"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前K个最大数]]></title>
        <id>https://tienyeung.github.io//post/qian-k-ge-zui-da-shu</id>
        <link href="https://tienyeung.github.io//post/qian-k-ge-zui-da-shu">
        </link>
        <updated>2019-10-17T01:50:20.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>问题：查找大量无序元素中最大的K个数。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>问题：查找大量无序元素中最大的K个数。</p>
</blockquote>
<!-- more -->
<h1 id="解法一">解法一</h1>
<p>该解法是大部分能想到的，也是第一想到的方法。假设数据量不大，可以先用快速排序或堆排序，他们的平均时间复杂度为O(N<em>logN),然后取出前K个，时间复杂度为O(K)，总的时间复杂度为O(N</em>logN)+O(K).<br>
当K=1时，上面的算法的时间复杂度也是O(N*logN)，<em>上面的算法是把整个数组都进行了排序，而原题目只要求最大的K个数，并不需要前K个数有限，也不需要后N-K个数有序。可以通过部分排序算法如选择排序和交换排序，把N个数中的前K个数排序出来，复杂度为O(N</em>K),选择哪一个，取决于K的大小，在K(K&lt;logN)较小的情况下，选择部分排序。</p>
<h1 id="解法二">解法二</h1>
<p>假设N个数存储在数组S中，从数组中随机找一个元素X，将数组分成两部分Sa和Sb.Sa中的元素大于等于X,Sb中的元素小于X。<br>
    出现如下两种情况：<br>
   (1)若Sa组的个数大于或等于K，则继续在sa分组中找取最大的K个数字 。<br>
   (2)若Sa组中的数字小于K ，其个数为T，则继续在sb中找取 K-T个数字 。<br>
一直这样递归下去，不断把问题分解成小问题，平均时间复杂度为O(N*logK)。</p>
<pre><code class="language-c++">
/*将数组a[s]...a[t]中的元素用一个元素划开，保存中a[k]中*/
void partition(int a[], int s,int t,int &amp;k)  
{  
    int i,j,x;  
    x=a[s];    //取划分元素   
    i=s;        //扫描指针初值   
    j=t;  
    do  
    {  
        while((a[j]&lt;x)&amp;&amp;i&lt;j) j--;   //从右向左扫描,如果是比划分元素小，则不动
        if(i&lt;j) a[i++]=a[j];           //大元素向左边移   
        while((a[i]&gt;=x)&amp;&amp;i&lt;j) i++;      //从左向右扫描，如果是比划分元素大，则不动 
        if(i&lt;j) a[j--]=a[i];            //小元素向右边移   
  
    }while(i&lt;j); //直到指针i与j相等    
a[i]=x;      //划分元素就位   
k=i;  
}  
/*查找数组前K个最大的元素，index:返回数组中最大元素中第K个元素的下标(从0开始编号),high为数组最大下标*/
int FindKMax(int a[],int low,int high,int k)
{ 
     int q;
int index=-1;
   if(low &lt; high)  
      {  
        partition(a , low , high,q);  
        int len = q - low + 1; //表示第几个位置    
        if(len == k)  
         index=q; //返回第k个位置   
        else if(len &lt; k)   
         index= FindKMax(a , q + 1 , high , k-len);     
       else 
        index=FindKMax(a , low , q - 1, k);  
      }  
    return index;
 
}
int main()
{
     int a[]={20,100,4,2,87,9,8,5,46,26};  
    int Len=sizeof(a)/sizeof(int); 
     int K=4;
 FindKMax(a , 0 , Len- 1 , K) ;    
    for(int i = 0 ; i &lt; K ; i++)  
      cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;  
 return 0;
}
</code></pre>
<h1 id="解法三">解法三</h1>
<p>该问题的实质是寻找最大的K个数中最小的那个，也就是第K大的数p，可以先找出N个数中最大的和最小的元素的值，然后使用二分法进行搜索找到p，再根据p找到其他大于它的K-1个数。其时间复杂度是O(N)+O(NlogN)+O(N)，近似后为O(NlogN)。</p>
<pre><code class="language-python">while Vmax-Vmin&gt;delta:
    Vmid=Vmin+(Vmax-Vmin)*0.5
    #f(arr,N,Vmid)返回数组arr中不小于Vmid的数的个数
    #delta取值比任何两数之差小，如果元素是整数可以取0.5
    if f(arr,N,Vmid) &gt;= k:
        Vmin=Vmid
    else:
        Vmax=Vmid
</code></pre>
<h1 id="解法四">解法四</h1>
<p>如果N个数都是正数，取值范围不太大，可以考虑用空间换时间。申请一个包括N中最大值的MAXN大小的数组count[MAXN]，count[i]表示整数i在所有整数中的个数。这样只要扫描一遍数组，就可以得到第K大的元素。</p>
<pre><code class="language-c++">for(sumCount = 0, v = MAXN -1; v &gt;=0; v--)  
{  
       cumCount += count[v];  
       if(sumCount &gt;= k)  
            break;  
}  
return v; 
</code></pre>
<h1 id="解法五">解法五</h1>
<p>当N的数值很大的时候，即N&gt;&gt;K。从N个数中任取K个数建立一个有K个节点的小顶堆，每次从剩下N-K个数中取出一个数，与堆顶元素进行比较，若小于等于堆顶元素则舍弃，若大于等于堆顶，则将堆顶元素更新为该元素并重新调整堆。维护堆的时间复杂度是O(logK)。所以总的时间复杂度是O(NlogK)。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;  

using namespace std;  

void buildMinHeap(int *pArray, int K);
void adjustHeap(int *pArray, int rootIndex, int heapSize);

int main()  
{  
    int a[] = {9, 8, 7, 6, 5, 4, 3, 11, 12, 13, 1, 28};
    int K = 5 ;

    //建一个K个元素大小的最小堆
    buildMinHeap(a, K);

    //从第K个元素开始扫描，看有没有比根节点更大的节点，若有则替换，并更新堆；若没有比根节点大则扫描下一个元素，直到数组结束
    for (int i = K; i &lt; sizeof(a) / sizeof(int); i++)
    {
        if (a[i] &gt; a[0])
        {
            swap(a[i], a[0]);
            adjustHeap(a, 0, K);
        }
    }

    //打印出前K大的数，没有排序。
    for (int i = 0; i &lt; K; i++)
    {
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    }
    system(&quot;pause&quot;);
}  

//建一个K个元素大小的最小堆
void buildMinHeap(int *pArray, int K)
{
    for (int i = (K - 2) / 2; i &gt;= 0; i--)
    {
        adjustHeap (pArray, i, K);
    }
}

void adjustHeap (int *pArray, int rootIndex, int heapSize)
{
    int minIndex = rootIndex;

    //左孩子节点
    int leftIndex = 2 * rootIndex + 1;

    //右孩子节点
    int rightIndex = 2 * (rootIndex + 1);

    //如果左孩子比根节点和右孩子节点小的话，则左孩子和根节点进行交换
    if ((leftIndex &lt; heapSize) &amp;&amp; (rightIndex &lt; heapSize) &amp;&amp;
        (pArray[leftIndex] &lt; pArray[rootIndex]))
    {
        minIndex = leftIndex;
    }
    if ((leftIndex &lt; heapSize) &amp;&amp; (rightIndex &gt;= heapSize) &amp;&amp; 
        (pArray[leftIndex] &lt; pArray[rootIndex]))
    {
        minIndex = leftIndex;
    }


    if ((rightIndex &lt; heapSize) &amp;&amp; (pArray[rightIndex] &lt;
         pArray[leftIndex]) &amp;&amp; (pArray[rightIndex] &lt; 
             pArray[rootIndex]))
    {
        minIndex = rightIndex;
    }

    if (minIndex != rootIndex) 
    {
        //如果左孩子或者右孩子比根节点小的话，那么就交换，并且重新调整以
        //minIndex为根节点的子树
        swap(pArray[rootIndex], pArray[minIndex]);
        adjustHeap(pArray, minIndex, heapSize);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有趣的阶乘]]></title>
        <id>https://tienyeung.github.io//post/you-qu-de-jie-cheng</id>
        <link href="https://tienyeung.github.io//post/you-qu-de-jie-cheng">
        </link>
        <updated>2019-10-16T02:06:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>阶乘（Factorial）是个很有意思的函数，但是不少人都比较怕它，我们来看看两个与阶乘相关的问题：1．给定一个整数N，那么N的阶乘N！末尾有多少个0呢？例如：N＝10，N！＝3628800，N！的末尾有两个0。2．求N！的二进制表示中最低位1的位置。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>阶乘（Factorial）是个很有意思的函数，但是不少人都比较怕它，我们来看看两个与阶乘相关的问题：1．给定一个整数N，那么N的阶乘N！末尾有多少个0呢？例如：N＝10，N！＝3628800，N！的末尾有两个0。2．求N！的二进制表示中最低位1的位置。</p>
</blockquote>
<!-- more -->
<h1 id="问题1">问题1</h1>
<p>零是由2和5相乘算出的，也就是说多少个0就有多少个2和5相乘；同时4和5相乘也为0，但4是2的倍数，也就是说偶数与5相乘为0，如此看来2比5多，因此多少个0就是n由多少个5组成，同时25，75等含有2个5，3个5，诱导公式为f(n) = n/5 + n/5^2 + n/5^3 + n/5^4 + n/5^5+..<br>
即可用递归：</p>
<pre><code class="language-python">class Solution(object):
    def trailingZeroes(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        count=0
        while n&gt;=5:
            return n//5+self.trailingZeroes(n//5)
        return count
</code></pre>
<h1 id="问题2">问题2</h1>
<p>首先来看一下一个二进制数除以2的计算过程和结果是怎样的。<br>
把一个二进制数除以2，实际过程如下：<br>
判断最后一个二进制位是否为0，若为0，则将此二进制数右移一位，即为商值；反之，若为1，则说明这个二进制数是奇数，无法被2整除。即二进制最低位为0代表是偶数，如果为1则代表是奇数。<br>
所以，这个问题实际上等同于求N！含有质因数2的个数。即答案等于N！含有质因数2的个数加1。<br>
由于N！中含有质因数2的个数，等于N/2＋N/4＋N/8＋N/16＋…</p>
<pre><code class="language-python">class Solution(object):
    def trailingZeroes(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        count=0
        while n:
            n&gt;&gt;=1
            count+=N
        return count
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nim游戏]]></title>
        <id>https://tienyeung.github.io//post/nim-you-xi</id>
        <link href="https://tienyeung.github.io//post/nim-you-xi">
        </link>
        <updated>2019-10-15T01:52:02.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Nim游戏是博弈论中最经典的模型，它又有着十分简单的规则和无比优美的结论.通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。这游戏看上去有点复杂，k可以考虑从简单情况开始研究。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Nim游戏是博弈论中最经典的模型，它又有着十分简单的规则和无比优美的结论.通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。这游戏看上去有点复杂，k可以考虑从简单情况开始研究。</p>
</blockquote>
<!-- more -->
<h1 id="第一种类型">第一种类型</h1>
<blockquote>
<p>N块石头排成一行，两个玩家依次取石头，每个玩家可以取其中任意一块或者相邻的两块，最后能将剩下的石头一次取光的玩家获胜。</p>
</blockquote>
<p>当题目中由“N个”字眼出现时，可以从一些简单的特例出发，进而掌握解题规律。</p>
<ul>
<li>N=1、N=2，先取者必胜</li>
<li>N=3，先取者取中间1块石头，左右还剩下各1块石头，无论第二个人怎么取，己方必胜</li>
<li>N=4，先取者取中间2块石头，还是左右各剩一块，己方必胜</li>
<li>N&gt;4时，先取者只要取中间的元素，N为奇数取中间一个，偶数取中间两个，将石头分为两部分，然后无论第二个人怎么取，先取者只要在另一部分的对称位置取走同样多的石头，则最后先取者必胜。</li>
</ul>
<p>思考：若规定最后取光石头的人输，如何应对？</p>
<h1 id="第二种类型">第二种类型</h1>
<blockquote>
<p>有N块石头和两个玩家A和B，玩家A先将石头随机分成若干堆，然后按照BABA...的顺序不断轮流取石头，能将剩下的石头一次取光的玩家获胜，每次取石头时，每个玩家只能从若干堆石头中任选一堆，取这一堆石头中任意数目（大于0）个石头。</p>
</blockquote>
<p>同样，不妨从特例出发，N表示石头堆数，M表示石头总数。</p>
<ul>
<li>N=1时，无论多少石头，只有一堆，对方必胜</li>
<li>N=2时，最简单是每堆1个石头，即（1，1），对手拿，无论怎样，己方必胜</li>
<li>N=2，M&gt;2时，我们称（1，1）为安全局面，那么（1，x）就不是安全局面，只要当前方把局面造成（1，1），那么对方必输，同样（2，2）是安全的，因为对方不能一次性把局面造成（1，1），以此类推，（x，x）是安全的。也就是说，如果石头是偶数个，即可以分成两堆，则己方必胜。</li>
<li>若石头是奇数个，M=3,两种情况（2，1），（1，1，1）则先拿者必胜</li>
<li>M=5,同样情况，先拿者必胜</li>
<li>可以得出阶段性结论：若（1，1，.....)摆放时，1为奇数个，则先拿者必胜；1为偶数个，先拿者必输。想要先拿者必胜，则需摆放为（1，1，...，x），若1有奇数个，从x中拿出x-1个即可，剩下偶数个1；若1有偶数个，把x个全拿走，剩下偶数个1。</li>
</ul>
<p>当然还有其它摆法，如何得出必胜技呢？--<strong>异或（XOR)</strong>！<br>
<strong>同0异一，与0异或为本身</strong></p>
<h2 id="m为偶数时取胜策略是把m分成两堆">M为偶数时，取胜策略是把M分成两堆。</h2>
<p>|开始|(M1,M1)|XOR(M1, M1) == 0|<br>
|中途|(M1,M2)|XOR(M1, M2) != 0|<br>
|我方|(M2,M2)|XOR(M2, M2) != 0|<br>
|最后|(0,0)|我方取胜|</p>
<h2 id="如果石头的个数n为奇数b有必胜的方法">如果石头的个数N为奇数，B有必胜的方法。</h2>
<p>初始：XOR(M1, M2, ... , Mn) != 0<br>
玩家B：XOR(M1, ... , Mi', ... , Mn) == 0 （其中一堆Mi的个数减少到Mi'）<br>
玩家A：XOR(M1, ... , Mj', ... , Mn) != 0 <br>
玩家B：XOR(M1, ... , Mi', ... , Mn) == 0 （其中一堆Mi的个数减少到Mi'）<br>
结果：XOR(M1, ... , Mj' , ... , Mn) == 0 （直到结束状态(0,0)）</p>
<h2 id="这里就有个问题已知xorm1-m2-mn-0玩家b该改变那个mi以使得xorm1-mi-mn-0呢">这里就有个问题：已知XOR(M1, M2, ... , Mn) != 0，玩家B该改变那个Mi以使得XOR(M1, ... , Mi', ... , Mn) == 0呢？</h2>
<p>设k=XOR(M1, M2, ... , Mn)，已知k!=0，存在一个数Mi，其二进制表达中在k的最高二进制位上的数为1，且这个数Mi肯定存在（k的这个最高位在异或运算中肯定来自某一个Mi）。这时Mi^k &lt; Mi一定成立。则我们可以将Mi改变成Mi'=Mi^k，</p>
<p>简单证明：即假设k的二进制表达是1xx，那么Mi的二进制表达是x...x1xx，这样玩家B将该Mi改成Xi'=XOR(Mi, k)后，Mi'的二进制表达是x...x0yy，肯定小于Mi，并且有XOR(M1, ... , Mi', ... , Mn) == 0。</p>
<h1 id="第三种类型">第三种类型</h1>
<blockquote>
<p>假设有两堆石头，有两个玩家会根据如下的规则轮流取石头：每人每次可以从两堆石头中各取出数量相等的石头，或者仅从一堆石头中取出任意数量的石头；最后把剩下的石头一次拿光的人获胜。请问在哪些局面（依据两堆石头中的石头个数）下，先取石头的玩家有必胜的策略。</p>
</blockquote>
<h2 id="筛选法">筛选法</h2>
<p>类似构造质数的厄式筛选法：把所有数字排列出来，从2开始，既然2是质数，那么2的倍数一定不是质数，筛去2的倍数，下个数字3没被筛去，则他就是质数因为他不能被小于他的数整除，筛去3的倍数，依次类推。</p>
<p>回到Nim问题，我们从（10，10）中找出所有组合，对称的先筛去，先取者必胜的安全局面先筛去，即筛去（1，1），（2，2）...（10，10），剩下的表的第一个就是（1，2）不安全局面，则可达到（1，2）的就是安全局面，筛去（1，n），（2，n）也可以一步转化为（2，1），筛去（2，n），接下来就是（3，5）不安全局面，能一步到达（3，5）的就是安全局面，筛去(3，n)(n,3)(5,n)(n,5)(3+n,5+n)。依次类推。剩下的就是不安全局面了，此类方法为自底向上推理算法。、</p>
<h2 id="通项公式法">通项公式法</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mo>[</mo><mi>a</mi><mo>∗</mo><mi>n</mi><mo>]</mo><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub><mo>=</mo><mo>[</mo><mi>b</mi><mo>∗</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a_n=[a*n],b_n=[b*n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a=\frac{1+\sqrt{5}}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>=</mo><mfrac><mrow><mn>3</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">b=\frac{3+\sqrt{5}}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
证明详见《编程之美》1.13</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电梯调度算法]]></title>
        <id>https://tienyeung.github.io//post/dian-ti-diao-du-suan-fa</id>
        <link href="https://tienyeung.github.io//post/dian-ti-diao-du-suan-fa">
        </link>
        <updated>2019-10-14T02:04:07.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>所有的员工均在1楼进电梯的时候，选择所要到达的楼层。然后计算出停靠的楼层i，当到达楼层i的时候，电梯停止.所有人走出电梯，步行到所在的楼层中。求所有人爬的楼层数目和的最小值。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>所有的员工均在1楼进电梯的时候，选择所要到达的楼层。然后计算出停靠的楼层i，当到达楼层i的时候，电梯停止.所有人走出电梯，步行到所在的楼层中。求所有人爬的楼层数目和的最小值。</p>
</blockquote>
<!-- more -->
<p>最简单的方法和最容易想到的就是穷举法，遍历乘客的停靠楼层并计算在某个楼层的总爬楼梯数，时间复杂度是平方级别。</p>
<p>优化一下，假设停靠在第i层，假设在i处下楼的客人为N2,在i以上楼层的客人数目为N3 ，在i以下楼层的客人数目为N1。 且将电梯在i层停止时，全部人员的路程之和记为T。</p>
<p>那么假如电梯在i-1层停的话，则原来i层之上的人需要多爬一层，即增加了N3，第i层的人需要多爬一层，则结果增加了N2,  i层之下的人则少爬了一层，结果减去N1，所以第i-1层的结果为 T - N1 + N2 + N3 。即结果可以即为 T -(N1 - N2 - N3) <br>
      <br>
考虑在i+1层的结果，若电梯在i+1层停止的话，原来i层之上的客户都会少爬一层，则结果减少N3 ，而i层之下的人员则都会多爬一层即增加了N1 ，第i层的人员都会多爬一层即为增加了N2 。则结果为 T + N1 + N2 - N3 <br>
————————————————<br>
综上我们得出，<br>
      (1) 若N1 &gt; N2 + N3的时候， 我们在第i-1层 选择电梯停止最好。<br>
      (2) 若N1 + N2 &lt; N3的时候， 我们选择在第i+1层停止电梯最好。  <br>
        <br>
下面我们可以先计算出来当i=1时候的T ，然后判断是否需要在i+1层停止，若是i+1层的花费大于i层，则我们可以继续计算，否则退出。<br>
————————————————</p>
<pre><code class="language-java">
public class Lift 
{
	static final int N = 10 ;
	static int person[] = {0, 2, 5 , 7 , 3 , 5 , 2 , 6, 2 , 6 , 3}; 
	public static void main(String[] args)
	{
		System.out.print(compute(person)+&quot; &quot;+compute2(person));
	}
	public static int compute(int[] person)
	{
	      //先计算出在第一层停止的时候 所需要的花费
	       int T = 0;
	       int N1 = 0 ; //在第一层以下下的人数 
	       int N2 = person[1] ; //在第一层处下的人数 
	       int N3 = 0 ;      //在第一层之上下电梯的人数 
	       int floor =  1 ;
	       for(int i = 2 ; i &lt;= N ;i++) //先计算出第1层停止需要爬取的楼层数目 
	       {
	         T  += person[i] * (i - 1) ;
	         N3 += person[i] ;     
	       }
	        
	       for(int i = 2 ; i &lt;= N ;i++)
	       {
	         if(N1 + N2 &lt;= N3) //说明第i+1层的结果会大于第i层 
	           {
	               T += N1 + N2 - N3 ;
	               N1 += N2 ;
	               N2 = person[i] ; 
	               N3 -= person[i] ;
	               floor = i ;
	               
	           }     
	           else  //否则第i层的结果已经最小，故不需要计算第i+1层 
	           break ; 
	            
	       }     
	       return floor ;
	}
	public static int compute2(int[] person)
	{
		      int tempfloor = 0 ;
		      int min = 6553 ;//存储最小值
		      int floor = 1   ;//存储停靠的楼层 
		      int j;
		      for(int i = 1 ; i &lt;= N ;i++) //表示第i楼层电梯停靠 
		      {
		        tempfloor = 0 ;         
		        for(j = 1 ; j &lt; N ;j++)      
		            tempfloor += Math.abs((i - j)) * person[j] ;         
		        if(min &gt; tempfloor)   
		        {
		          min = tempfloor ;
		          floor = i ;          
		        }       		                        
		      }
		      return floor ;	  
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法之美]]></title>
        <id>https://tienyeung.github.io//post/suan-fa-zhi-mei</id>
        <link href="https://tienyeung.github.io//post/suan-fa-zhi-mei">
        </link>
        <updated>2019-10-11T02:55:32.000Z</updated>
        <summary type="html"><![CDATA[<p>我们所有人的生活都受到有限空间和有限时间的限制，因此常常面临一系列难以抉择的问题。在一天或者一生的时光里，哪些事是我们应该做的，哪些是应该放弃的？我们对杂乱无序的容忍底线是什么？新的活动与熟悉并喜爱的活动之间如何平衡，才能取得令人愉快的结果？这些看似是人类特有的难题，其实不然，因为计算机也面临同样的问题，计算机科学家几十年来也一直在努力解决这些问题，而他们找到的解决方案可以给我们很多启发。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我们所有人的生活都受到有限空间和有限时间的限制，因此常常面临一系列难以抉择的问题。在一天或者一生的时光里，哪些事是我们应该做的，哪些是应该放弃的？我们对杂乱无序的容忍底线是什么？新的活动与熟悉并喜爱的活动之间如何平衡，才能取得令人愉快的结果？这些看似是人类特有的难题，其实不然，因为计算机也面临同样的问题，计算机科学家几十年来也一直在努力解决这些问题，而他们找到的解决方案可以给我们很多启发。</p>
<!-- more -->
<h1 id="1-最优停止理论">1 最优停止理论</h1>
<blockquote>
<p>租房经历：我们必须在看房期间作出决定，我们总是会担心两个事情：担心看过的好房子被别人抢走，还有其他好房子还没看到。这就要求我们必须在继续挑选和立刻下手之间作出一个决定，并达成某种平衡。那么到底该怎么办，如何找打这个平衡点，能让我们的决定更加明智？</p>
</blockquote>
<p>在数学上我们得到了答案！37%，也就是说你在看前37%房子时不要作出决定，等过了这个数字，我们就得做好随时签约租房协议的事情，假如我们有一个月的找房时间。那么在前11天我们尽管看房，明确我们的标准，等过了11天遇到合适的房子我们就要准备随时签合同了。这个37%理论就是数学上“最优停止”理论了，也叫做<a href="https://zh.wikipedia.org/wiki/%E7%A7%98%E6%9B%B8%E5%95%8F%E9%A1%8C">秘书问题</a>。</p>
<h2 id="何时应用最优停止理论">何时应用最优停止理论</h2>
<ul>
<li>博弈的存在，不管是招人还是租房，我们都需要作出决定：博弈是选择还是拒绝；</li>
<li>机会成本，不管是招人还是租房，我们都需要承担因选择而错失更好，或因拒绝而失去更好的成本；</li>
<li>信息不对称，都是在很难获取到全面的数据情况下作出选择。</li>
</ul>
<h1 id="2-探索与利用">2 探索与利用</h1>
<blockquote>
<p>在生活过程中，探索新事物和珍惜当下一直是一个矛盾。要最新的还是要最好的？</p>
</blockquote>
<h2 id="基廷斯指数">基廷斯指数</h2>
<blockquote>
<p>多臂老虎机：老虎机是赌场里最常见的一个设备，一家赌场里有那么多机器，每次摇动都可能后悔或者获得一定额度的奖励，你通过选择不同的老虎机臂最大化自己的利益。</p>
</blockquote>
<p>其实这就是探索和利用的平衡问题，你自然希望赢钱越多越好，于是，肯定会在不同机器上亲自测试一番（探索），然后专挑认为可能吐钱amde机器来玩游戏（利用），在几台重复实验过的老虎机中如何选择，这取决到你在赌场里<strong>准备玩多长时间</strong>。</p>
<p>时间是个很重要的参数，随着时间的推移，我们认真品味新发现的机会也会所剩无几，因此探索的价值随之降低;反之，利用的价值将随着时间不断上升。要用优化算法处理多臂老虎机问题难度极大，于是，有人提出了<strong>赢留输变</strong>的算法：只要老虎机不断吐钱，便留下来继续玩，反之，则选择下一台。显然，“输走”这个原则有待商榷，并未考虑到剩余时间概念，于是，基廷斯算法应运而生。</p>
<blockquote>
<p>他说，当你计划出去吃一顿饭的时候，明天那顿应该比今天这顿要贬值一点 —— 因为你明天可能会离开这里，吃不上那顿饭。具体贬值多少，取决于你预期还能停留多长时间。基于这一点，他提出了一个非常复杂的解决方案，最后结果是给每个选项计算了一个指数，现在被称为“基廷斯指数（Gittins Index）”</p>
</blockquote>
<p>下面这张表，就是在假设第二顿饭比第一顿饭贬值1%的情况下，各种局面的基廷斯指数。</p>
<figure data-type="image" tabindex="1"><img src="https://tienyeung.github.io//post-images/1570764660749.png" alt=""></figure>
<p>比如你正在跟女朋友讨论晚上去哪里吃饭。老餐馆，你们去过15次，其中9次感觉很好，6次感觉不好，那么就是9个wins，6个losses，根据表格，基廷斯指数是0.6997。而新餐馆你们并没有去过，所以wins和losses都为0，基廷斯指数是0.8699。基廷斯指数给一次都没去过的新餐馆一个非常高的估值，这就是因为它可能给你带来惊喜，要积极探索。但这个探索不是无条件的 —— 根据表格，如果你们去过老餐馆9次每次都很好，那么老餐馆的基廷斯指数就是0.9655，那就没必要去这个新餐馆。事实上，哪怕女朋友说的这个新餐馆，你们已经去过两次，一次体验好一次不好，那么新餐馆的基廷斯指数仍然高达0.7844，你们还是应该去。这是因为小样本的统计很可能不准，也许一次不好只是偶然，你应该给它更多机会。而对比之下，老餐馆已经去过多次，测量结果已经稳定在一个一般的水平了。</p>
<p><strong>用基廷斯指数解决探索/收获问题，其实有一个隐含的假设，那就是你的转换是没有成本的。今天在这间餐馆吃饭，明天去新餐馆，可以随便去。可是对于换工作之类的问题，其实存在一个适应新单位的转换成本，那就要考虑得更复杂一点了。</strong></p>
<h2 id="上限置信区间">上限置信区间</h2>
<p>人绝非全知全能，那势必会存在遗憾，只是或多或少，或快或慢而已。基廷斯指数考虑的剩余时间，而<a href="https://segmentfault.com/a/1190000018871668">上限置信区间</a>考虑的便是遗憾最少化。原理“面对不确定性的乐观主义”。其强调用一只证据推断某个选择方案可能产生的最佳结果，计算结果倾向于我们了解程度较低的可能情况。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最好的时代]]></title>
        <id>https://tienyeung.github.io//post/zui-hao-de-shi-dai</id>
        <link href="https://tienyeung.github.io//post/zui-hao-de-shi-dai">
        </link>
        <updated>2019-10-10T02:27:53.000Z</updated>
        <summary type="html"><![CDATA[<p>要问最好的时代是什么时候，毫无疑问就是当下，就是即将迈入21世纪20年代的新时代中国。如果真的有一部时光机，我不会想穿越回文艺青年热衷的民国，因为我知道那时军阀割据，战乱频仍，即便是大师众多，英雄辈出，于普通民众而言仍是苦不堪言。也不会想穿越回大明书粉向往的明朝，因为我知道那时生产力极度落后，当政者的最高愿景并非是发展生产力，提升民众幸福度，而仅仅是保持社会稳定，而到达“黎民不饥不寒”的最低标准而已，即便上层阶级生活安逸，但底层百姓却占大多数，即便穿越回去大概率只是当一个生活困苦，苛捐杂税缠身的中下贫农而已。</p>
]]></summary>
        <content type="html"><![CDATA[<p>要问最好的时代是什么时候，毫无疑问就是当下，就是即将迈入21世纪20年代的新时代中国。如果真的有一部时光机，我不会想穿越回文艺青年热衷的民国，因为我知道那时军阀割据，战乱频仍，即便是大师众多，英雄辈出，于普通民众而言仍是苦不堪言。也不会想穿越回大明书粉向往的明朝，因为我知道那时生产力极度落后，当政者的最高愿景并非是发展生产力，提升民众幸福度，而仅仅是保持社会稳定，而到达“黎民不饥不寒”的最低标准而已，即便上层阶级生活安逸，但底层百姓却占大多数，即便穿越回去大概率只是当一个生活困苦，苛捐杂税缠身的中下贫农而已。</p>
<!-- more -->
<p>那我为什么还要写最好的时代，难道不是显而易见的么？放在时代洪流面前，的确是的，但放在个人命运前面，却有待分说。其实写这篇文章我是在怀念一些人我认为的最好的时代，他们最好的时代我已经错过，如今不论颜值，演技，心态已不复从前。我喜欢周星驰，梁朝伟，喜欢那个时代群星闪耀的香港电影的黄金时代，梁朝伟的电影我看过85%以上，周星驰的电影我看过95%以上，他们的综艺访谈我也有意搜索看过，他们的最好的时代开始于90年代，巅峰时期就处在新世纪来临前10年，如今虽有零星作品问世，但质量也不如从前了，不得不感叹韶华的逝去。周星驰的最后一部出演的电影是12年前的《长江七号》，我以为以后会有更好的作品问世，没想到可能已成绝唱，之后的出任导演的作品只能说差强人意。梁朝伟的最近一部电影是《欧洲攻略》，其实从拍了《摆渡人》《捉妖记2》我就知道，梁朝伟的时代可能也已经过去了，最后一部佳作已是7年前的《一代宗师》，这部从构思到杀青一共经历13年的电影，一如王家卫的一贯作风，消磨了太多时光，虽然慢工出细活，但梁朝伟却或许因此少拍了许多佳作，加上之前的《2046》拍了整整四年，梁朝伟全程在组，几乎没出演过任何影片，这于我们观众而言不失为一种巨大的遗憾，那个时期正是梁朝伟的黄金时期，四十岁出头，演技颜值精力仍在巅峰，本可以一鼓作气多出几部好片的。可对此梁朝伟却觉得无所谓，只要有角色让他释放情绪就好了，果然，这才是佛系的梁先生，那么闲暇时飞到伦敦一言不发喂一下午鸽子的事迹也就不足为奇了：）</p>
<p>我不能见证他们最好的时代是我无比的遗憾，每当看见他们当时在电影或综艺访谈里的帅气脸庞和意气风发，与如今的极少的出镜率和沉默寡言寥寥数语的访谈对比，我都感到无比的怀念。不该是这样的，或许是我常常回顾他们的电影，他们的电影放在当下仍不算脱节，恍惚间，我一直以为他们现在还像电影里一样帅气逼人，才华横溢，直到看到电影出品日期时我才恍然：这不是10年前的作品，已经是20年前甚至30年前的作品了。时间过得怎么能这么快！</p>
<p>其实你我都知道时间的流逝是均匀的，无所谓快慢，周，梁二人比我早出生太多，甚至比我爸年纪还大出不少，但我却能把他们当作我的偶像，是因为我看到的作品永远是他们年轻时代的作品，自我懂事来，他们便甚少作品问世，以至于我觉得他们仍一如年少模样。他们的过去我无法参与，我能参与的只是回顾他们往日时光的作品而已。</p>
<p>我喜欢的周杰伦，现在已为人夫，为人父，事业成功，家庭美满，时光把他的棱角打磨了不少，变得成熟稳重，或许再也写不出以往或深情或自负或遗憾的作品了，我同样没有参与他状态最巅峰的时代，惭愧的是，大多80，90后视为周青春的周杰伦我却是在2015年才正式入坑的，我的青春是许嵩。那个时候的我只是零星听过几首杰伦的歌，还不是之后的我那样成为狂热的公举粉，看过几乎所有访谈，听过几乎所有杰伦的歌。我入坑后一年，周杰伦发布了目前为止最后一张专辑，也还算差强人意，只是似乎缺了点什么。</p>
<p>所以我总是会感概：为何我总是错过他们最好的时代，对他们的最好的时代我唯一能做的就只是怀念回忆而已。或许我就是一个喜欢怀旧的人，我不想喜欢一个在当今正处巅峰状态的人，因为我看不出他们的成就，梁朝伟是金像奖获奖最多的影帝，周星驰是无厘头鼻祖喜剧天才，周杰伦是金曲奖获奖最多的音乐鬼才，我都是在他们功成名就许久后才喜欢他们的。或许需要时光的沉淀才能让一个人绽放光彩，也许我不是恰好错过了他们的绽放，而正因为他们绽放才会驻留。</p>
<p>怀念无济于事，时光终究逝去，能做的也许就是把握当下吧！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二进制数中1的个数]]></title>
        <id>https://tienyeung.github.io//post/er-jin-zhi-zhong-1-de-ge-shu</id>
        <link href="https://tienyeung.github.io//post/er-jin-zhi-zhong-1-de-ge-shu">
        </link>
        <updated>2019-10-09T10:39:05.000Z</updated>
        <summary type="html"><![CDATA[<p>做题时常常能遇到如何计算二进制数中的1的个数，在此做一个总结，因为我觉得比较有代表性，且有特殊方法可考。同时，欢迎和我讨论力扣解题思想，目前做了100多题，每题的解题思路都上传到了我的<a href="https://github.com/tienyeung/leetcode">github</a>,望多指正！</p>
]]></summary>
        <content type="html"><![CDATA[<p>做题时常常能遇到如何计算二进制数中的1的个数，在此做一个总结，因为我觉得比较有代表性，且有特殊方法可考。同时，欢迎和我讨论力扣解题思想，目前做了100多题，每题的解题思路都上传到了我的<a href="https://github.com/tienyeung/leetcode">github</a>,望多指正！</p>
<!-- more -->
<p><strong>如下有两种方法</strong>：</p>
<h1 id="按位与">按位与</h1>
<p>即将该二进制数与1相与，若不为0，说明该位(最低位)上为1，然后将1左移一位，依次与二进制数对比。</p>
<pre><code class="language-python">class Solution(object):
    def hammingWeight(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        bits=0
        mask=1
        for i in range(0,32):
            if n&amp;mask !=0 :
                bits+=1
            mask&lt;&lt;=1
        return bits
</code></pre>
<h1 id="特殊方法">特殊方法</h1>
<p>将该数不断同比自己小1的数相与，直到结果为0为止。为什么n &amp;= (n – 1)能清除最右边的1呢？因为从二进制的角度讲，n相当于在n - 1的最低位加上1。举个例子，8（1000）= 7（0111）+ 1（0001），所以8 &amp; 7 = （1000）&amp;（0111）= 0（0000），清除了8最右边的1（其实就是最高位的1，因为8的二进制中只有一个1）。再比如7（0111）= 6（0110）+ 1（0001），所以7 &amp; 6 = （0111）&amp;（0110）= 6（0110），清除了7的二进制表示中最右边的1（也就是最低位的1）。</p>
<pre><code class="language-python">def count1(n):
        res = 0
        while n!=0:
            n&amp;=(n-1)
            res+=1
        
        return res
</code></pre>
]]></content>
    </entry>
</feed>